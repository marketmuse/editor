{"version":3,"sources":["App.js","../../node_modules/is-plain-object/index.js","../../node_modules/is-plain-object/node_modules/isobject/index.js","../../node_modules/esrever/esrever.js","../../node_modules/immer/dist/immer.esm.js","../../node_modules/lodash/_listCacheClear.js","../../node_modules/lodash/eq.js","../../node_modules/lodash/_assocIndexOf.js","../../node_modules/lodash/_listCacheDelete.js","../../node_modules/lodash/_listCacheGet.js","../../node_modules/lodash/_listCacheHas.js","../../node_modules/lodash/_listCacheSet.js","../../node_modules/lodash/_ListCache.js","../../node_modules/lodash/_stackClear.js","../../node_modules/lodash/_stackDelete.js","../../node_modules/lodash/_stackGet.js","../../node_modules/lodash/_stackHas.js","../../node_modules/lodash/_freeGlobal.js","../../node_modules/lodash/_root.js","../../node_modules/lodash/_Symbol.js","../../node_modules/lodash/_getRawTag.js","../../node_modules/lodash/_objectToString.js","../../node_modules/lodash/_baseGetTag.js","../../node_modules/lodash/isObject.js","../../node_modules/lodash/isFunction.js","../../node_modules/lodash/_coreJsData.js","../../node_modules/lodash/_isMasked.js","../../node_modules/lodash/_toSource.js","../../node_modules/lodash/_baseIsNative.js","../../node_modules/lodash/_getValue.js","../../node_modules/lodash/_getNative.js","../../node_modules/lodash/_Map.js","../../node_modules/lodash/_nativeCreate.js","../../node_modules/lodash/_hashClear.js","../../node_modules/lodash/_hashDelete.js","../../node_modules/lodash/_hashGet.js","../../node_modules/lodash/_hashHas.js","../../node_modules/lodash/_hashSet.js","../../node_modules/lodash/_Hash.js","../../node_modules/lodash/_mapCacheClear.js","../../node_modules/lodash/_isKeyable.js","../../node_modules/lodash/_getMapData.js","../../node_modules/lodash/_mapCacheDelete.js","../../node_modules/lodash/_mapCacheGet.js","../../node_modules/lodash/_mapCacheHas.js","../../node_modules/lodash/_mapCacheSet.js","../../node_modules/lodash/_MapCache.js","../../node_modules/lodash/_stackSet.js","../../node_modules/lodash/_Stack.js","../../node_modules/lodash/_setCacheAdd.js","../../node_modules/lodash/_setCacheHas.js","../../node_modules/lodash/_SetCache.js","../../node_modules/lodash/_arraySome.js","../../node_modules/lodash/_cacheHas.js","../../node_modules/lodash/_equalArrays.js","../../node_modules/lodash/_Uint8Array.js","../../node_modules/lodash/_mapToArray.js","../../node_modules/lodash/_setToArray.js","../../node_modules/lodash/_equalByTag.js","../../node_modules/lodash/_arrayPush.js","../../node_modules/lodash/isArray.js","../../node_modules/lodash/_baseGetAllKeys.js","../../node_modules/lodash/_arrayFilter.js","../../node_modules/lodash/stubArray.js","../../node_modules/lodash/_getSymbols.js","../../node_modules/lodash/_baseTimes.js","../../node_modules/lodash/isObjectLike.js","../../node_modules/lodash/_baseIsArguments.js","../../node_modules/lodash/isArguments.js","../../node_modules/lodash/stubFalse.js","../../node_modules/lodash/isBuffer.js","../../node_modules/lodash/_isIndex.js","../../node_modules/lodash/isLength.js","../../node_modules/lodash/_baseIsTypedArray.js","../../node_modules/lodash/_baseUnary.js","../../node_modules/lodash/_nodeUtil.js","../../node_modules/lodash/isTypedArray.js","../../node_modules/lodash/_arrayLikeKeys.js","../../node_modules/lodash/_isPrototype.js","../../node_modules/lodash/_overArg.js","../../node_modules/lodash/_nativeKeys.js","../../node_modules/lodash/_baseKeys.js","../../node_modules/lodash/isArrayLike.js","../../node_modules/lodash/keys.js","../../node_modules/lodash/_getAllKeys.js","../../node_modules/lodash/_equalObjects.js","../../node_modules/lodash/_DataView.js","../../node_modules/lodash/_Promise.js","../../node_modules/lodash/_Set.js","../../node_modules/lodash/_WeakMap.js","../../node_modules/lodash/_getTag.js","../../node_modules/lodash/_baseIsEqualDeep.js","../../node_modules/lodash/_baseIsEqual.js","../../node_modules/lodash/isEqual.js","../../node_modules/lodash/_arrayMap.js","../../node_modules/lodash/_arrayEach.js","../../node_modules/lodash/_defineProperty.js","../../node_modules/lodash/_baseAssignValue.js","../../node_modules/lodash/_assignValue.js","../../node_modules/lodash/_copyObject.js","../../node_modules/lodash/_baseAssign.js","../../node_modules/lodash/_nativeKeysIn.js","../../node_modules/lodash/_baseKeysIn.js","../../node_modules/lodash/keysIn.js","../../node_modules/lodash/_baseAssignIn.js","../../node_modules/lodash/_cloneBuffer.js","../../node_modules/lodash/_copyArray.js","../../node_modules/lodash/_copySymbols.js","../../node_modules/lodash/_getPrototype.js","../../node_modules/lodash/_getSymbolsIn.js","../../node_modules/lodash/_copySymbolsIn.js","../../node_modules/lodash/_getAllKeysIn.js","../../node_modules/lodash/_initCloneArray.js","../../node_modules/lodash/_cloneArrayBuffer.js","../../node_modules/lodash/_cloneDataView.js","../../node_modules/lodash/_cloneRegExp.js","../../node_modules/lodash/_cloneSymbol.js","../../node_modules/lodash/_cloneTypedArray.js","../../node_modules/lodash/_initCloneByTag.js","../../node_modules/lodash/_baseCreate.js","../../node_modules/lodash/_initCloneObject.js","../../node_modules/lodash/_baseIsMap.js","../../node_modules/lodash/isMap.js","../../node_modules/lodash/_baseIsSet.js","../../node_modules/lodash/isSet.js","../../node_modules/lodash/_baseClone.js","../../node_modules/lodash/isSymbol.js","../../node_modules/lodash/_isKey.js","../../node_modules/lodash/memoize.js","../../node_modules/lodash/_memoizeCapped.js","../../node_modules/lodash/_stringToPath.js","../../node_modules/lodash/_baseToString.js","../../node_modules/lodash/toString.js","../../node_modules/lodash/_castPath.js","../../node_modules/lodash/last.js","../../node_modules/lodash/_toKey.js","../../node_modules/lodash/_baseGet.js","../../node_modules/lodash/_baseSlice.js","../../node_modules/lodash/_parent.js","../../node_modules/lodash/_baseUnset.js","../../node_modules/lodash/isPlainObject.js","../../node_modules/lodash/_customOmitClone.js","../../node_modules/lodash/_isFlattenable.js","../../node_modules/lodash/_baseFlatten.js","../../node_modules/lodash/flatten.js","../../node_modules/lodash/_apply.js","../../node_modules/lodash/_overRest.js","../../node_modules/lodash/constant.js","../../node_modules/lodash/identity.js","../../node_modules/lodash/_baseSetToString.js","../../node_modules/lodash/_shortOut.js","../../node_modules/lodash/_setToString.js","../../node_modules/lodash/_flatRest.js","../../node_modules/lodash/omit.js","../../node_modules/slate/dist/index.es.js","../../node_modules/direction/index.js","../../node_modules/lodash/now.js","../../node_modules/lodash/toNumber.js","../../node_modules/lodash/debounce.js","../../node_modules/lodash/throttle.js","../../node_modules/compute-scroll-into-view/es/index.js","../../node_modules/scroll-into-view-if-needed/es/index.js","../../node_modules/is-hotkey/lib/index.js","../../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../../node_modules/slate-react/dist/index.es.js","../../src/utils/cleanUrl.js","../../src/utils/isValidUrl.js","../../src/utils/classHasFocus.js","../../src/components/toolbar/ToolbarButton.js","../../src/components/toolbar/ToolbarInput.js","../../src/components/toolbar/ItemSpacer.js","../../src/plugins/defaultToolbar.js","../../src/config/common.js","../../src/plugins/pluginParagraph.js","../../src/plugins/pluginText.js","../../src/plugins/pluginLists.js","../../src/plugins/pluginGoogleDocs.js","../../src/plugins/pluginMsOffice.js","../../src/plugins/htmlDeserializerOptions.js","../../src/plugins/pluginMarks.js","../../src/plugins/pluginHeadings.js","../../src/editor/focus/focus.js","../../src/editor/focus/hasFocus.js","../../src/editor/contents/getDocumentEdgePoint.js","../../src/editor/cursor/moveCursorToStart.js","../../src/editor/cursor/moveCursorToEnd.js","../../src/editor/links/getLink.js","../../node_modules/lodash/get.js","../../src/editor/links/isLinkActive.js","../../src/editor/links/removeLink.js","../../src/editor/links/insertLink.js","../../src/editor/links/replaceLink.js","../../src/editor/contents/selectAll.js","../../node_modules/lodash/isNil.js","../../src/config/initialValue.js","../../src/editor/contents/clear.js","../../src/editor/contents/isEmpty.js","../../src/editor/contents/getPlainText.js","../../src/editor/formatters/isFormatActive.js","../../src/editor/selection/normalizeSelection.js","../../src/editor/formatters/toggleFormat.js","../../src/config/versions.js","../../src/editor/serializer/serializeRaw/serializeRaw.js","../../src/editor/data/export.js","../../src/editor/serializer/serializeHtml/serializeHtml.js","../../src/editor/data/exportHtml.js","../../src/editor/deserializer/deserializeRaw/utils/walk.js","../../src/editor/deserializer/deserializeRaw/migrations/index.js","../../src/editor/deserializer/deserializeRaw/migrations/v0v1.js","../../src/editor/deserializer/deserializeRaw/deserializeRaw.js","../../src/editor/data/import.js","../../node_modules/lodash/_assignMergeValue.js","../../node_modules/lodash/_createBaseFor.js","../../node_modules/lodash/_baseFor.js","../../node_modules/lodash/isArrayLikeObject.js","../../node_modules/lodash/_safeGet.js","../../node_modules/lodash/toPlainObject.js","../../node_modules/lodash/_baseMergeDeep.js","../../node_modules/lodash/_baseMerge.js","../../node_modules/lodash/_baseRest.js","../../node_modules/lodash/_isIterateeCall.js","../../node_modules/lodash/_createAssigner.js","../../node_modules/lodash/merge.js","../../src/utils/cleanHtml.js","../../src/editor/deserializer/deserializeHtml/utils/strategiesToDict.js","../../src/editor/deserializer/deserializeHtml/utils/extractAttributes.js","../../src/utils/mapReduceFlatten.js","../../src/editor/deserializer/deserializeHtml/utils/combineOptions.js","../../src/editor/deserializer/deserialize/postDeserializeNormalization.js","../../src/utils/removeBabelProps.js","../../src/editor/deserializer/deserialize/index.js","../../src/editor/deserializer/deserializeHtml/deserializeHtml.js","../../src/editor/data/insertHtml.js","../../src/editor/deserializer/deserializeText/deserializeText.js","../../src/editor/data/insertText.js","../../src/editor/formatters/toggleHeading.js","../../src/utils/test/populateWindow.js","../../src/editor/cursor/isCollapsed.js","../../src/editor/hooks/useFormats.js","../../src/editor/hooks/useFunctions.js","../../src/editor/hooks/useDecors.js","../../node_modules/slate-history/dist/index.es.js","../../src/editor/enhancer/withPersistedSelection.js","../../src/editor/enhancer/withLinks.js","../../src/editor/enhancer/withDeserializer.js","../../src/editor/enhancer/withNormalizer.js","../../src/editor/enhancer/withOnInsertData.js","../../src/editor/events/getExecuteCallback.js","../../src/utils/mapReduceFlattenDict.js","../../src/components/Portal.js","../../src/components/toolbar/ToolbarWrapper.js","../../src/components/toolbar/Toolbar.js","../../src/MMSEditorConsumer.js","../../src/components/editor/leafs/Bold.js","../../src/components/editor/leafs/Italic.js","../../src/components/editor/leafs/Underline.js","../../src/components/editor/leafs/Strikethrough.js","../../src/components/editor/leafs/index.js","../../src/components/editor/Leaf.js","../../src/components/editor/elements/Paragraph.js","../../src/components/editor/elements/Blockquote.js","../../src/components/editor/elements/HeadingOne.js","../../src/components/editor/elements/HeadingTwo.js","../../src/components/editor/elements/HeadingThree.js","../../src/components/editor/elements/Link.js","../../src/components/editor/elements/ListBulleted.js","../../src/components/editor/elements/ListNumbered.js","../../src/components/editor/elements/ListItem.js","../../src/components/editor/elements/index.js","../../src/components/editor/Element.js","../../src/components/editor/useRenderers.js","../../src/editor/hotkeys/getHandleHotkeys.js","../../src/editor/hotkeys/prepareHotkeys.js","../../src/editor/events/useEvents.js","../../src/editor/events/getExecuteEvent.js","../../node_modules/rollup-plugin-bundle-worker/src/workerhelper.js","../../src/editor/decorators/decorateWorker.js","../../src/editor/decorators/utils/getDecoratorKey.js","../../src/editor/decorators/getDecorComponents.js","../../src/editor/decorators/getDecorTriggers.js","../../src/editor/decorators/utils/regexFromRegex.js","../../src/editor/decorators/utils/normalizeString.js","../../src/editor/decorators/utils/isStringValid.js","../../src/editor/decorators/utils/regexFromString.js","../../src/editor/decorators/decorator.js","../../src/utils/test/isTest.js","../../src/MMSEditorProvider.js","../../src/editor/formats.js","../../src/editor/functions.js","../../src/editor/hotkeys/useHotkeys.js","../../src/MMSEditor.js","../../src/editor/plugins/applyPlugins.js","../../src/editor/enhancer/withMarketmuse.js","serviceWorker.js","index.js"],"names":["Separator","props","className","text","HooksTest","formatsHookTest","useFormats","functionsHookTest","useFunctions","style","position","display","onMouseDown","e","preventDefault","toggleBold","isBold","onClick","clear","Blue","backgroundColor","color","children","Red","borderBottom","App","useState","code","setCode","setText","url","setUrl","raw","setRaw","html","setHtml","htmlExport","setHtmlExport","redHighlights","setRedHighlights","blueHighlights","setBlueHighlights","defaultCode","hotkeyPlugin","hotkeys","key","when","formats","isCollapsed","command","alert","decoratorPlugin","decorators","id","match","split","component","triggers","extendFormatsPlugin","isStyled","isItalic","isUnderlined","isStrikethrough","extendFunctionsPlugin","functions","isLink","eventExamplePlugin","onKeyDown","event","onValueChangePlugin","onValueChange","forcedLayoutPlugin","normalizerOptions","normalize","editor","node","path","isTopLevel","length","isFirst","isSecond","isHeading","type","types","h1","isParagraph","p","slate","Transforms","unwrapNodes","at","wrapNodes","copyPastePlugin","onCut","console","log","onCopy","onInsertData","data","getData","plugins","decors","toolbar","window","isUnderline","isH1","isH2","isH3","isBlockquote","isListNumbered","isListBulleted","isFocused","dTotal","get","aBlue","mBlue","aRed","mRed","renderHtmlExport","value","margin","exported","exportHtml","renderImportsExports","onChange","target","parsed","JSON","parse","import","stringify","export","history","renderHighlights","Object","keys","map","k","border","placeholder","renderLinks","disabled","insertLink","removeLink","renderFormatters","toggleItalic","toggleUnderline","toggleStrikethrough","toggleHeading","toggleBlockquote","toggleListNumbered","toggleListBulleted","renderSelections","focus","moveCursorToStart","moveCursorToEnd","selectAll","renderContentControls","insertText","insertHtml","renderJsPanel","_populateWindow","useCode","eval","_getEditor","isObjectObject","o","isObject","val","Array","isPlainObject","ctor","prot","freeExports","freeModule","module","freeGlobal","root","regexSymbolWithCombiningMarks","regexSurrogatePair","esrever","reverse","result","index","string","die","error","args","Error","msg","other","array","eq","splice","this","assocIndexOf","ListCache","entries","entry","__data__","has","global","freeSelf","self","Function","objectProto","hasOwnProperty","nativeObjectToString","symToStringTag","Symbol","isOwn","tag","getRawTag","objectToString","baseGetTag","maskSrcKey","uid","exec","coreJsData","func","funcToString","reIsHostCtor","funcProto","reIsNative","RegExp","isMasked","isFunction","pattern","toSource","object","getValue","baseIsNative","getNative","nativeCreate","Hash","Map","isKeyable","getMapData","size","MapCache","pairs","LARGE_ARRAY_SIZE","Stack","SetCache","values","predicate","cache","bitmask","customizer","equalFunc","stack","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","arraySome","cacheHas","set","symbolProto","symbolValueOf","convert","equalArrays","offset","keysFunc","symbolsFunc","isArray","arrayPush","resIndex","propertyIsEnumerable","nativeGetSymbols","arrayFilter","n","iteratee","isObjectLike","exports","Buffer","isBuffer","reIsUint","typedArrayTags","isLength","freeProcess","nodeUtil","nodeIsTypedArray","baseUnary","inherited","isArr","isArg","isArguments","isBuff","isType","isTypedArray","skipIndexes","baseTimes","isIndex","Ctor","transform","overArg","isPrototype","nativeKeys","isArrayLike","arrayLikeKeys","baseKeys","baseGetAllKeys","objProps","getAllKeys","objLength","skipCtor","objValue","objCtor","othCtor","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","DataView","ArrayBuffer","Promise","Set","WeakMap","ctorString","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","equalObjects","baseIsEqual","baseIsEqualDeep","defineProperty","baseAssignValue","source","isNew","newValue","assignValue","copyObject","nativeKeysIn","isProto","baseKeysIn","keysIn","allocUnsafe","buffer","getSymbols","getPrototype","getSymbolsIn","arrayBuffer","dataView","isDeep","cloneArrayBuffer","reFlags","regexp","symbol","typedArray","cloneDataView","cloneTypedArray","cloneRegExp","cloneSymbol","objectCreate","baseCreate","nodeIsMap","nodeIsSet","cloneableTags","baseClone","isFlat","isFull","initCloneArray","copyArray","isFunc","cloneBuffer","initCloneObject","copySymbolsIn","baseAssignIn","copySymbols","baseAssign","initCloneByTag","isSet","subValue","isMap","undefined","arrayEach","reIsDeepProp","reIsPlainProp","isSymbol","memoize","resolver","TypeError","memoized","rePropName","reEscapeChar","memoizeCapped","quote","subString","number","symbolToString","baseToString","arrayMap","isKey","stringToPath","toString","castPath","toKey","start","end","baseGet","baseSlice","parent","last","objectCtorString","proto","spreadableSymbol","baseFlatten","depth","isStrict","thisArg","nativeMax","Math","otherArgs","apply","constant","nativeNow","Date","count","lastCalled","stamp","remaining","arguments","shortOut","setToString","overRest","flatRest","paths","getAllKeysIn","CLONE_DEEP_FLAG","baseUnset","String","rtl","ltr","LTR","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isBinary","nativeMin","wait","options","lastInvokeTime","leading","maxing","trailing","lastArgs","lastThis","timerId","setTimeout","timerExpired","invokeFunc","timeSinceLastCall","time","lastCallTime","now","shouldInvoke","trailingEdge","timeWaiting","maxWait","remainingWait","isInvoking","leadingEdge","clearTimeout","toNumber","debounced","debounce","isElement","el","canOverflow","overflow","skipOverflowHiddenElements","isScrollable","getComputedStyle","frame","getFrameElement","isHiddenByFrame","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","scrollMode","block","inline","boundary","checkBoundary","scrollingElement","document","frames","cursor","viewportWidth","visualViewport","viewportHeight","viewportX","viewportY","_target$getBoundingCl","targetHeight","targetWidth","targetTop","targetRight","targetBottom","targetLeft","targetBlock","targetInline","computations","_frame$getBoundingCli","height","width","top","right","bottom","left","frameStyle","borderLeft","parseInt","borderTop","borderRight","blockScroll","inlineScroll","scrollbarWidth","scrollbarHeight","scrollLeft","scrollTop","isOptionsObject","scrollIntoView","targetIsDetached","compute","computeOptions","getOptions","actions","behavior","canSmoothScroll","_ref","defaultBehavior","IS_MAC","test","MODIFIERS","alt","control","meta","shift","ALIASES","add","break","cmd","ctl","ctrl","del","down","esc","ins","mod","opt","option","return","space","spacebar","up","win","windows","CODES","backspace","tab","enter","pause","capslock","escape","pageup","pagedown","home","arrowleft","arrowup","arrowright","arrowdown","insert","delete","numlock","scrolllock","f","hotkey","parseHotkey","check","compareHotkey","byKey","ret","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","optional","name","toKeyName","modifier","toKeyCode","err","expected","actual","isHotkey","invariant","condition","message","href","addHttps","clean","classname","activeElement","ToolbarButton","PropTypes","active","callback","ItemSpacer","BackToDefaultScreen","RemoveLinkButton","OpenLinkButton","link","cleanUrl","isValid","isValidUrl","LinkInput","useEditor","useEffect","existing","isPopupScreen","onFormSubmit","onSubmit","isOpen","forceScreen","classHasFocus","defaultScreen","screens","h2","h3","a","ul","ol","li","q","b","i","u","s","attrs","parentPath","isBackspace","isEnter","matcher","item","Editor","htmlDeserializerOptions","transforms","newEl","transformGdocs","tags","container","wrapped","newTag","acc","base","newChildren","c","activeListRef","transformMsOffice","_el","child","wrapper","wrapTextNodes","isLast","listItem","body","normalizedHtmlString","str","normalizeHtmlString","strategies","strategy","onKeyUp","ReactEditor","edge","positionsGen","getDocumentEdgePoint","defaultValue","isLinkActive","selection","Range","linkConfig","currentLink","getLink","currentLinkText","newLinkText","updatePath","startPoint","endPoint","anchor","initialRange","setValue","isNil","Node","format","marks","extendsToNextBlock","focusAtOffsetZero","distance","unit","status","normalizeSelection","toggleOn","isFormatActive","Text","listTypeTypes","isListType","version","data_version","slate_version","packageJson","slate_history_version","slate_react_version","metadata","serializeRaw","serializeHtml","out","serializeHtmlNodes","nodes","delim","useNodes","walk","newNode","migrations","to","fn","editorData","deserializeRaw","migration","migrate","deserialized","fromRight","iterable","createBaseFor","srcIndex","mergeFunc","safeGet","srcValue","assignMergeValue","isCommon","isTyped","isArrayLikeObject","toPlainObject","baseMerge","baseFor","baseMergeDeep","assigner","baseRest","sources","guard","isIterateeCall","createAssigner","res","arg","list","htmlDeserializerOptionsList","mapReduceFlatten","fragments","leaf","custom","_instructions","_instructionsTag","bold","italic","strikethrough","paragraph","_","headingThree","blockQuote","fragment","isKnown","useTag","removeBabelProps","pre","deserializeHtml","inherit","strategiesDict","current","htmlAttrs","extractAttributes","nodeType","nodeName","textContent","strategySkip","strategyContinue","strategyContinueText","strategyText","strategyTextChildren","_inherited","deserialize","_instructionsForChildren","merge","_instructionsForCurrentNode","isStyleTag","childrenArgs","childrenLeafArgs","childrenNodeArgs","isText","hasTextContent","instructionArgs","cleanHtml","rootEl","combineOptions","postDeserializeNormalization","strategiesToDict","force","useText","t","deserializeText","level","useType","toggleFormat","FormatsApiContext","createContext","formatsApi","useContext","FunctionsApiContext","functionsApi","DecoratorContext","History","Operation","lastSelection","insertData","isInline","element","htmlString","textString","normalizeNode","execCallback","callbacks","params","currentAcc","currentItem","ReactDOM","TooolbarWrapper","inlineTop","useRef","inlineLeft","useSlate","inlineProps","marginTop","zIndex","hasFocus","hasFocusWithin","isVisible","rect","domSelection","newTop","newLeft","bool","ToolbarComponent","screen","renderProps","setScreen","forcedScreen","currentScreen","toolbarPropTypes","isRequired","MMSEditorConsumer","decorate","renderElement","renderLeaf","handleHotkeys","execEvent","apiArgs","spellCheck","autoCorrect","autoCapitalize","readOnly","autoFocus","editorClassName","onBeforeInput","onBlur","onFocus","onCompositionStart","onCompositionEnd","onDragOver","onDragStart","onDrop","onMouseUp","Bold","Italic","Underline","Strikethrough","Leaf","attributes","Component","leafs","dkey","Paragraph","Blockquote","HeadingOne","HeadingTwo","HeadingThree","Link","ListBulleted","ListNumbered","ListItem","Element","elements","any","dict","logic","shouldRun","prepareHotkeys","validators","rest","validate","events","useCallback","getExecuteEvent","getExecuteCallback","TARGET","BlobBuilder","URL","Worker","objURL","createSourceObject","testArray","Uint8Array","navigator","testWorker","Blob","blob","selfShim","postMessage","m","_self","defineProp","writable","enumerable","configurable","commands","echo","total","matches","aggregates","ranges","processRegex","d","rgx","terms","term","termSafe","range","walkAcc","rg","d1","r1","r2","rangesDict","r","generateRanges","decorator","getDecoratorKey","regex","flags","wholeWord","useString","normalizeString","isStringValid","generate","pathJoined","leafUpdater","setLeafUpdater","regexFromRegex","regexFromString","getDecorTriggers","getDecorComponents","MMSEditorProvider","state","setState","pluginsDict","extendCore","formatsRaw","getFormats","functionsRaw","isEmpty","getPlainText","replaceLink","importFn","exportFn","_setValue","populateWindow","getFunctions","decorComponents","decorTriggers","useRenderers","getHandleHotkeys","useHotkeys","useEvents","MMSEditor","useDefaultPlugins","useMemo","useDefaults","usePlugins","mapReduceFlattenDict","normalizerOptionsList","onPaste","plugin","newFormats","newFunctions","applyPlugins","withReact","withPersistedSelection","withHistory","withLinks","withNormalizer","withDeserializer","withOnInsertData","withMarketmuse","createEditor","Boolean","location","hostname","render","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b3e4068f.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport get from 'lodash/get';\nimport MMSEditor, { types, slate, useFormats, useFunctions } from '@marketmuse/editor';\nimport '@marketmuse/editor/dist/mms-editor.css';\n\nimport './App.css';\n\nconst Separator = props => (\n  <div className=\"separator\">\n    <span>{props.text}</span>\n  </div>\n);\n\nfunction HooksTest() {\n  const formatsHookTest = useFormats();\n  const functionsHookTest = useFunctions();\n\n  return (\n    <div style={{ position: 'absolute', display: 'flex' }}>\n      <button\n        onMouseDown={e => {\n          e.preventDefault();\n          functionsHookTest.toggleBold();\n        }}\n      >\n        {formatsHookTest.isBold ? 'bold' : 'not bold'}\n      </button>\n      <button onClick={() => functionsHookTest.clear()}>\n        clear\n      </button>\n    </div>\n  );\n}\n\nconst Blue = props => (\n  <span style={{ backgroundColor: 'blue', color: 'white' }} >\n    {props.children}\n  </span>\n);\n\nconst Red = props => (\n  <span style={{ borderBottom: '2px solid red' }} >\n    {props.children}\n  </span>\n);\n\nfunction App() {\n\n  const [code, setCode] = useState('');\n  const [text, setText] = useState('');\n  const [url, setUrl] = useState('google.com');\n  const [raw, setRaw] = useState('');\n  const [html, setHtml] = useState('');\n  const [htmlExport, setHtmlExport] = useState('');\n\n  const [redHighlights, setRedHighlights] = useState('lorem, lorem ipsum');\n  const [blueHighlights, setBlueHighlights] = useState('apm tools, apm');\n  const defaultCode = 'functions.focus();\\nfunctions.moveCursorToStart()\\nconsole.log(\"cursor moved\")';\n\n  // add hotkeys\n  const hotkeyPlugin = {\n    hotkeys: [{\n      key: 'mod+b',\n      when: ({ formats }) => formats.isCollapsed,\n      command: () => alert('select some text for best results!'),\n    }],\n  };\n\n  // add decorators\n  const decoratorPlugin = {\n    decorators: [\n      {\n        id: 'blue',\n        match: blueHighlights.split(','),\n        component: Blue,\n        triggers: [blueHighlights],\n      },\n      {\n        id: 'red',\n        match: redHighlights.split(','),\n        component: Red,\n        triggers: [redHighlights],\n      }\n    ],\n  };\n\n  // extend formats api\n  const extendFormatsPlugin = {\n    formats: formats => ({\n      ...formats,\n      isStyled: (\n        formats.isBold ||\n        formats.isItalic ||\n        formats.isUnderlined ||\n        formats.isStrikethrough\n      )\n    }),\n  }\n\n  // extend functions api\n  const extendFunctionsPlugin = {\n    functions: (functions, { formats }) => ({\n      ...functions,\n      toggleBold: (...args) => {\n        // do not make bold if link\n        if (formats.isLink) return;\n        // default behaviour\n        functions.toggleBold(...args);\n      }\n    })\n  };\n\n  // showcase event plugins\n  const eventExamplePlugin = {\n    onKeyDown: (event, { functions, formats }) => {\n      if (event.key === 'Enter') {\n        // block keypress\n        // event.preventDefault();\n        // use formats api like so\n        // if (formats.isBold) console.log('This is bold!');\n        // else console.log('This is not bold!');\n      }\n    }\n  };\n\n  // test onValueChange\n  const onValueChangePlugin = {\n    onValueChange: ({ functions, formats }) => {\n      // if (formats.isBold) console.log('This is bold!');\n      // else console.log('This is not bold!');\n    }\n  }\n\n  // plugin that will make first block hading\n  // and the second block a paragraph\n  const forcedLayoutPlugin = {\n    normalizerOptions: {\n      normalize: (editor, [ node, path ]) => {\n        const isTopLevel = path.length === 1;\n        const isFirst = path[0] === 0;\n        const isSecond = path[0] === 1;\n        const isHeading = node.type === types.h1;\n        const isParagraph = node.type === types.p;\n\n        // make first block heading\n        if (isTopLevel && isFirst && !isHeading) {\n          slate.Transforms.unwrapNodes(editor, { at: path });\n          slate.Transforms.wrapNodes(editor, { children: [], type: types.h1 }, { at: path })\n          return true;\n        }\n\n        // make second block paragraph\n        if (isTopLevel && isSecond && !isParagraph) {\n          slate.Transforms.unwrapNodes(editor, { at: path });\n          slate.Transforms.wrapNodes(editor, { children: [], type: types.p }, { at: path })\n          return true;\n        }\n\n        return false;\n      }\n    }\n  }\n\n  // test events\n  const copyPastePlugin = {\n    onCut: (e) => { console.log('cut', e) },\n    onCopy: (e) => { console.log('copy', e) },\n    onInsertData: data => { console.log('insert', data, data.getData('text/plain')) }\n  };\n\n  return (\n    <MMSEditor\n      plugins={[\n        hotkeyPlugin,\n        decoratorPlugin,\n        extendFormatsPlugin,\n        extendFunctionsPlugin,\n        eventExamplePlugin,\n        onValueChangePlugin,\n        // copyPastePlugin,\n        // forcedLayoutPlugin,\n      ]}\n    >\n      {({\n        decors,\n        formats,\n        functions,\n        toolbar,\n        editor,\n      }) => {\n        window.functions = functions;\n        window.decors = decors;\n\n        const {\n          isBold,\n          isItalic,\n          isUnderline,\n          isStrikethrough,\n          isH1,\n          isH2,\n          isH3,\n          isLink,\n          isParagraph,\n          isBlockquote,\n          isListNumbered,\n          isListBulleted,\n          isCollapsed,\n          isFocused,\n        } = formats;\n\n        const dTotal = get(decors, 'total') || 0;\n        const aBlue = get(decors, 'aggregates.blue') || 0;\n        const mBlue = get(decors, 'matches.blue') || {};\n        const aRed = get(decors, 'aggregates.red') || 0;\n        const mRed = get(decors, 'matches.red') || {};\n\n        const renderHtmlExport = () => {\n          return (\n            <>\n              <Separator text=\"Export HTML\" />\n              <section className=\"col\">\n                <textarea\n                  className=\"has-item-below\"\n                  style={{ borderBottom: 'none' }}\n                  value={htmlExport}\n                />\n                <section style={{ margin: 0 }}>\n                  <button\n                    className=\"has-item-above has-item-right\"\n                    onClick={() => {\n                      const exported = functions.exportHtml();\n                      console.log('exported', exported);\n                      setHtmlExport(exported);\n                    }}\n                  >\n                    export\n                  </button>\n                </section>\n              </section>\n            </>\n          )\n        };\n\n        const renderImportsExports = () => {\n          return (\n            <>\n              <Separator text=\"Import / Export\" />\n              <label>Raw Data</label>\n              <section className=\"col\">\n                <textarea\n                  className=\"has-item-below\"\n                  style={{ borderBottom: 'none' }}\n                  // placeholder=\"Enter raw data...\"\n                  value={raw}\n                  onChange={e => setRaw(e.target.value)}\n                />\n                <section style={{ margin: 0 }}>\n                  <button\n                    className=\"has-item-above has-item-right\"\n                    onClick={() => {\n                      const parsed = JSON.parse(raw);\n                      console.log('parsed', parsed);\n                      functions.import(parsed);\n                    }}\n                  >\n                    import\n                  </button>\n                  <button\n                    className=\"has-item-above has-item-right has-item-left\"\n                    onClick={() => setRaw(JSON.stringify(functions.export()))}\n                  >\n                    export\n                  </button>\n                  <button\n                    className=\"has-item-above has-item-left\"\n                    onClick={() => setRaw(JSON.stringify(functions.export({ history: true })))}\n                  >\n                    export with history\n                  </button>\n                </section>\n              </section>\n            </>\n          )\n        };\n\n        const renderHighlights = () => {\n          return (\n            <>\n              <Separator text={`Decorations (${dTotal})`} />\n              <label>Blue ({aBlue})</label>\n              {Object.keys(mBlue).map(k => (\n                <label key={k} style={{ border: 'none' }}>{k}: {mBlue[k]}</label>\n              ))}\n              <section className=\"col\">\n                <input\n                  placeholder=\"Comma separated topics\"\n                  value={blueHighlights}\n                  onChange={e => setBlueHighlights(e.target.value)}\n                />\n              </section>\n              <label>Red ({aRed})</label>\n              {Object.keys(mRed).map(k => (\n                <label key={k} style={{ border: 'none' }}>{k}: {mRed[k]}</label>\n              ))}\n              <section className=\"col\">\n                <input\n                  placeholder=\"Comma separated topics\"\n                  value={redHighlights}\n                  onChange={e => setRedHighlights(e.target.value)}\n                />\n              </section>\n            </>\n          )\n        };\n\n        const renderLinks = () => {\n          return (\n            <>\n              <Separator text=\"Link\" />\n              <section className=\"col\">\n                <input\n                  className=\"has-item-below\"\n                  style={{ borderBottom: 'none' }}\n                  placeholder=\"Enter url...\"\n                  value={url}\n                  onChange={e => setUrl(e.target.value)}\n                />\n                <section style={{ margin: 0 }}>\n                  <button\n                    disabled\n                    className={`has-item-above has-item-right ${isLink ? 'active' : ''}`}\n                    onClick={() => {}}\n                  >\n                    is link\n                  </button>\n                  <button\n                    className=\"has-item-above has-item-left has-item-right\"\n                    onClick={() => functions.insertLink(url)}\n                  >\n                    insert link\n                  </button>\n                  <button\n                    className=\"has-item-above has-item-left\"\n                    onClick={() => functions.removeLink()}\n                  >\n                    remove link\n                  </button>\n                </section>\n              </section>\n            </>\n          )\n        };\n\n        const renderFormatters = () => {\n          return (\n            <>\n              <Separator text=\"Formatters\" />\n              <section className=\"merge-below\">\n                <button className={`has-item-right ${isBold ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleBold(); }}><b>bold</b></button>\n                <button className={`has-item-right has-item-left ${isItalic ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleItalic(); }}><i>italic</i></button>\n                <button className={`has-item-right has-item-left ${isUnderline ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleUnderline(); }}><u>underline</u></button>\n                <button className={`has-item-left ${isStrikethrough ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleStrikethrough(); }}><strike>strike</strike></button>\n              </section>\n              <section className=\"merge-below merge-above\">\n                <button disabled className={`has-item-right ${isParagraph ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); }}>p</button>\n                <button className={`has-item-right has-item-left ${isH1 ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleHeading(1); }}>h1</button>\n                <button className={`has-item-right has-item-left ${isH2 ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleHeading(2); }}>h2</button>\n                <button className={`has-item-left ${isH3 ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleHeading(3); }}>h3</button>\n              </section>\n              <section className=\"merge-above\">\n                <button className={`has-item-right ${isBlockquote ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleBlockquote(); }}>blockquote</button>\n                <button className={`has-item-right has-item-left ${isListNumbered ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleListNumbered(); }}>list (number)</button>\n                <button className={`has-item-left ${isListBulleted ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); functions.toggleListBulleted(); }}>list (bullet)</button>\n              </section>\n            </>\n          )\n        };\n\n        const renderSelections = () => {\n          return (\n            <>\n              <Separator text=\"Selection\" />\n              <section className=\"merge-below\">\n                <button disabled className={`has-item-right ${isFocused === true ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); }}>focused</button>\n                <button disabled className={`has-item-left has-item-right ${isCollapsed === true ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); }}>collapsed</button>\n                <button disabled className={`has-item-left ${isCollapsed === false ? 'active' : ''}`} onMouseDown={e => { e.preventDefault(); }}>selection</button>\n              </section>\n              <section className=\"merge-above\">\n                <button className=\"has-item-above has-item-right\" onClick={() => { functions.focus(); functions.moveCursorToStart(); }}>focus at start</button>\n                <button className=\"has-item-above has-item-right has-item-left\" onClick={() => functions.focus()}>focus</button>\n                <button className=\"has-item-above has-item-right has-item-left\" onClick={() => { functions.focus(); functions.moveCursorToEnd(); }}>focus at end</button>\n                <button className=\"has-item-above has-item-left\" onMouseDown={e => { e.preventDefault(); functions.selectAll(); }}>select all</button>\n              </section>\n            </>\n          )\n        };\n\n        const renderContentControls = () => {\n          return (\n            <>\n              <Separator text=\"Content\" />\n              <label>Text</label>\n              <section className=\"col\">\n                <textarea\n                  className=\"has-item-below\"\n                  style={{ borderBottom: 'none' }}\n                  placeholder=\"Enter text...\"\n                  value={text}\n                  onChange={e => setText(e.target.value)}\n                />\n                <section style={{ margin: 0 }}>\n                  <button\n                    className=\"has-item-above\"\n                    onMouseDown={e => {\n                      e.preventDefault();\n                      functions.insertText(text);\n                      setText('');\n                    }}\n                  >\n                    insert\n                  </button>\n                </section>\n              </section>\n              <label>HTML</label>\n              <section className=\"col\">\n                <textarea\n                  className=\"has-item-below\"\n                  style={{ borderBottom: 'none' }}\n                  placeholder=\"Enter html...\"\n                  value={html}\n                  onChange={e => setHtml(e.target.value)}\n                />\n                <section style={{ margin: 0 }}>\n                  <button\n                    className=\"has-item-above\"\n                    onMouseDown={e => {\n                      e.preventDefault();\n                      functions.insertHtml(html);\n                      setHtml('');\n                    }}\n                  >\n                    insert\n                  </button>\n                </section>\n              </section>\n            </>\n          )\n        };\n\n        const renderJsPanel = () => {\n          return (\n            <>\n              <Separator text=\"JS\" />\n              <section className=\"col\">\n                <textarea\n                  className=\"has-item-below\"\n                  style={{ borderBottom: 'none' }}\n                  placeholder={defaultCode}\n                  value={code}\n                  onChange={e => setCode(e.target.value)}\n                />\n                <section style={{ margin: 0 }}>\n                  <button\n                    className=\"has-item-above has-item-right\"\n                    onClick={() => {\n                      functions._populateWindow();\n                      console.log('code', code)\n                      console.log('defaultCode', defaultCode)\n                      const useCode = code || defaultCode;\n                      eval(useCode); // eslint-disable-line\n                    }}\n                  >\n                    eval\n                  </button>\n                  <button\n                    className=\"has-item-above has-item-left\"\n                    onClick={() => setCode('')}\n                  >\n                    clear\n                  </button>\n                </section>\n              </section>\n              <section>\n                <button onClick={() => console.log(functions._getEditor())}>log(editor)</button>\n                <button onClick={() => functions._populateWindow()}>populate window</button>\n              </section>\n            </>\n          );\n        };\n\n        return (\n          <div className=\"main-wrapper\">\n\n            {/* to test the hooks */}\n            <HooksTest />\n\n            {/* toolbar */}\n            {toolbar()}\n\n            {/* editor */}\n            <div className=\"editor-wrapper\">\n              <div className=\"container\">\n                {editor({ placeholder: 'Enter text' })}\n              </div>\n            </div>\n\n            {/* controls */}\n            <div className=\"control-wrapper\">\n              {renderHighlights()}\n              {renderFormatters()}\n              {renderLinks()}\n              {renderSelections()}\n              {renderContentControls()}\n              {renderHtmlExport()}\n              {renderImportsExports()}\n              {renderJsPanel()}\n            </div>\n          </div>\n        );\n      }}\n    </MMSEditor>\n\n  );\n}\n\nexport default App;\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","/*! https://mths.be/esrever v0.2.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar regexSymbolWithCombiningMarks = /([\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])([\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;\n\tvar regexSurrogatePair = /([\\uD800-\\uDBFF])([\\uDC00-\\uDFFF])/g;\n\n\tvar reverse = function(string) {\n\t\t// Step 1: deal with combining marks and astral symbols (surrogate pairs)\n\t\tstring = string\n\t\t\t// Swap symbols with their combining marks so the combining marks go first\n\t\t\t.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {\n\t\t\t\t// Reverse the combining marks so they will end up in the same order\n\t\t\t\t// later on (after another round of reversing)\n\t\t\t\treturn reverse($2) + $1;\n\t\t\t})\n\t\t\t// Swap high and low surrogates so the low surrogates go first\n\t\t\t.replace(regexSurrogatePair, '$2$1');\n\t\t// Step 2: reverse the code units in the string\n\t\tvar result = '';\n\t\tvar index = string.length;\n\t\twhile (index--) {\n\t\t\tresult += string.charAt(index);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar esrever = {\n\t\t'version': '0.2.0',\n\t\t'reverse': reverse\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn esrever;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = esrever;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in esrever) {\n\t\t\t\tesrever.hasOwnProperty(key) && (freeExports[key] = esrever[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.esrever = esrever;\n\t}\n\n}(this));\n","function n(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];if(\"production\"!==process.env.NODE_ENV){var i=Y[n],o=i?\"function\"==typeof i?i.apply(null,r):i:\"unknown error nr: \"+n;throw Error(\"[Immer] \"+o)}throw Error(\"[Immer] minified error nr: \"+n+(r.length?\" \"+r.map((function(n){return\"'\"+n+\"'\"})).join(\",\"):\"\")+\". Find the full error at: https://bit.ly/3cXEKWf\")}function t(n){return!!n&&!!n[Q]}function r(n){return!!n&&(function(n){if(!n||\"object\"!=typeof n)return!1;var t=Object.getPrototypeOf(n);return!t||t===Object.prototype}(n)||Array.isArray(n)||!!n[L]||!!n.constructor[L]||s(n)||v(n))}function e(r){return t(r)||n(23,r),r[Q].t}function i(n,t,r){void 0===r&&(r=!1),0===o(n)?(r?Object.keys:Z)(n).forEach((function(e){r&&\"symbol\"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function o(n){var t=n[Q];return t?t.i>3?t.i-4:t.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,t){return 2===o(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function a(n,t){return 2===o(n)?n.get(t):n[t]}function f(n,t,r){var e=o(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function c(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=nn(n);delete t[Q];for(var r=Z(t),e=0;e<r.length;e++){var i=r[e],o=t[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function d(n,e){y(n)||t(n)||!r(n)||(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,t){return d(t,!0)}),!0))}function h(){n(2)}function y(n){return null==n||\"object\"!=typeof n||Object.isFrozen(n)}function b(t){var r=tn[t];return r||n(18,t),r}function m(n,t){tn[n]||(tn[n]=t)}function _(){return\"production\"===process.env.NODE_ENV||U||n(0),U}function j(n,t){t&&(b(\"Patches\"),n.u=[],n.s=[],n.v=t)}function g(n){O(n),n.p.forEach(S),n.p=null}function O(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var t=n[Q];0===t.i||1===t.i?t.j():t.g=!0}function P(t,e){e._=e.p.length;var i=e.p[0],o=void 0!==t&&t!==i;return e.h.O||b(\"ES5\").S(e,t,o),o?(i[Q].P&&(g(e),n(4)),r(t)&&(t=M(e,t),e.l||x(e,t)),e.u&&b(\"Patches\").M(i[Q],t,e.u,e.s)):t=M(e,i,[]),g(e),e.u&&e.v(e.u,e.s),t!==H?t:void 0}function M(n,t,r){if(y(t))return t;var e=t[Q];if(!e)return i(t,(function(i,o){return A(n,e,t,i,o,r)}),!0),t;if(e.A!==n)return t;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(t,i){return A(n,e,o,t,i,r)})),x(n,o,!1),r&&n.u&&b(\"Patches\").R(e,r,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if(\"production\"!==process.env.NODE_ENV&&c===o&&n(5),t(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!t(v))return;e.m=!1}if(r(c)&&!y(c)){if(!e.h.N&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,t,r){void 0===r&&(r=!1),n.h.N&&n.m&&d(t,r)}function z(n,t){var r=n[Q];return(r?p(r):n)[t]}function I(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function E(n){n.P||(n.P=!0,n.l&&E(n.l))}function k(n){n.o||(n.o=l(n.t))}function R(n,t,r){var e=s(t)?b(\"MapSet\").T(t,r):v(t)?b(\"MapSet\").F(t,r):n.O?function(n,t){var r=Array.isArray(n),e={i:r?1:0,A:t?t.A:_(),P:!1,I:!1,D:{},l:t,t:n,k:null,o:null,j:null,C:!1},i=e,o=rn;r&&(i=[e],o=en);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(t,r):b(\"ES5\").J(t,r);return(r?r.A:_()).p.push(e),e}function D(e){return t(e)||n(22,e),function n(t){if(!r(t))return t;var e,u=t[Q],c=o(t);if(u){if(!u.P&&(u.i<4||!b(\"ES5\").K(u)))return u.t;u.I=!0,e=N(t,c),u.I=!1}else e=N(t,c);return i(e,(function(t,r){u&&a(u.t,t)===r||f(e,t,n(r))})),3===c?new Set(e):e}(e)}function N(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function T(){function r(n,t){var r=s[n];return r?r.enumerable=t:s[n]=r={configurable:!0,enumerable:t,get:function(){var t=this[Q];return\"production\"!==process.env.NODE_ENV&&f(t),rn.get(t,n)},set:function(t){var r=this[Q];\"production\"!==process.env.NODE_ENV&&f(r),rn.set(r,n,t)}},r}function e(n){for(var t=n.length-1;t>=0;t--){var r=n[t][Q];if(!r.P)switch(r.i){case 5:a(r)&&E(r);break;case 4:o(r)&&E(r)}}}function o(n){for(var t=n.t,r=n.k,e=Z(r),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=t[o];if(void 0===a&&!u(t,o))return!0;var f=r[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!t[Q];return e.length!==Z(t).length+(v?0:1)}function a(n){var t=n.k;if(t.length!==n.t.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);return!(!r||r.get)}function f(t){t.g&&n(3,JSON.stringify(p(t)))}var s={};m(\"ES5\",{J:function(n,t){var e=Array.isArray(n),i=function(n,t){if(n){for(var e=Array(t.length),i=0;i<t.length;i++)Object.defineProperty(e,\"\"+i,r(i,!0));return e}var o=nn(t);delete o[Q];for(var u=Z(o),a=0;a<u.length;a++){var f=u[a];o[f]=r(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(t),o)}(e,n),o={i:e?5:4,A:t?t.A:_(),P:!1,I:!1,D:{},l:t,t:n,k:i,o:null,g:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,r,o){o?t(r)&&r[Q].A===n&&e(n.p):(n.u&&function n(t){if(t&&\"object\"==typeof t){var r=t[Q];if(r){var e=r.t,o=r.k,f=r.D,c=r.i;if(4===c)i(o,(function(t){t!==Q&&(void 0!==e[t]||u(e,t)?f[t]||n(o[t]):(f[t]=!0,E(r)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,E(r))}));else if(5===c){if(a(r)&&(E(r),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function F(){function e(n){if(!r(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var t=Object.create(Object.getPrototypeOf(n));for(var i in n)t[i]=e(n[i]);return t}function f(n){return t(n)?e(n):n}var c=\"add\";m(\"Patches\",{$:function(t,r){return r.forEach((function(r){for(var i=r.path,u=r.op,f=t,s=0;s<i.length-1;s++)\"object\"!=typeof(f=a(f,i[s]))&&n(15,i.join(\"/\"));var v=o(f),p=e(r.value),l=i[i.length-1];switch(u){case\"replace\":switch(v){case 2:return f.set(l,p);case 3:n(16);default:return f[l]=p}case c:switch(v){case 1:return f.splice(l,0,p);case 2:return f.set(l,p);case 3:return f.add(p);default:return f[l]=p}case\"remove\":switch(v){case 1:return f.splice(l,1);case 2:return f.delete(l);case 3:return f.delete(r.value);default:return delete f[l]}default:n(17,u)}})),t},R:function(n,t,r,e){switch(n.i){case 0:case 4:case 2:return function(n,t,r,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?\"replace\":c:\"remove\";if(v!==p||\"replace\"!==l){var d=t.concat(n);r.push(\"remove\"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:\"remove\",path:d}:\"remove\"===l?{op:c,path:d,value:f(v)}:{op:\"replace\",path:d,value:f(v)})}}))}(n,t,r,e);case 5:case 1:return function(n,t,r,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,r];r=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=t.concat([v]);r.push({op:\"replace\",path:p,value:f(u[v])}),e.push({op:\"replace\",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=t.concat([l]);r.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:\"replace\",path:t.concat([\"length\"]),value:i.length})}(n,t,r,e);case 3:return function(n,t,r,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=t.concat([u]);r.push({op:\"remove\",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=t.concat([u]);r.push({op:c,path:o,value:n}),e.unshift({op:\"remove\",path:o,value:n})}u++}))}(n,t,r,e)}},M:function(n,t,r,e){r.push({op:\"replace\",path:[],value:t}),e.push({op:\"replace\",path:[],value:n.t})}})}function C(){function t(n,t){function r(){this.constructor=n}a(n,t),n.prototype=(r.prototype=t.prototype,new r)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(t){if(r(t)){var e=R(n.A.h,t,n);n.p.set(t,e),n.o.add(e)}else n.o.add(t)})))}function u(t){t.g&&n(3,JSON.stringify(p(t)))}var a=function(n,t){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},f=function(){function n(n,t){return this[Q]={i:2,l:t,A:t?t.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,g:!1},this}t(n,Map);var o=n.prototype;return Object.defineProperty(o,\"size\",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,t){var r=this[Q];return u(r),p(r).has(n)&&p(r).get(n)===t||(e(r),E(r),r.D.set(n,!0),r.o.set(n,t),r.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var t=this[Q];return u(t),e(t),E(t),t.D.set(n,!1),t.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),E(n),n.D=new Map,i(n.t,(function(t){n.D.set(t,!1)})),n.o.clear())},o.forEach=function(n,t){var r=this;p(this[Q]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},o.get=function(n){var t=this[Q];u(t);var i=p(t).get(n);if(t.I||!r(i))return i;if(i!==t.t.get(n))return i;var o=R(t.A.h,i,t);return e(t),t.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,t=this,r=this.keys();return(n={})[V]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},o.entries=function(){var n,t=this,r=this.keys();return(n={})[V]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,t){return this[Q]={i:3,l:t,A:t?t.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,g:!1,C:!1},this}t(n,Set);var r=n.prototype;return Object.defineProperty(r,\"size\",{get:function(){return p(this[Q]).size}}),r.has=function(n){var t=this[Q];return u(t),t.o?!!t.o.has(n)||!(!t.p.has(n)||!t.o.has(t.p.get(n))):t.t.has(n)},r.add=function(n){var t=this[Q];return u(t),this.has(n)||(o(t),E(t),t.o.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[Q];return u(t),o(t),E(t),t.o.delete(n)||!!t.p.has(n)&&t.o.delete(t.p.get(n))},r.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),E(n),n.o.clear())},r.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},r.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},r.keys=function(){return this.values()},r[V]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},n}();m(\"MapSet\",{T:function(n,t){return new f(n,t)},F:function(n,t){return new c(n,t)}})}function J(){T(),C(),F()}function K(n){return n}function $(n){return n}var G,U,W=\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol(\"x\"),X=\"undefined\"!=typeof Map,q=\"undefined\"!=typeof Set,B=\"undefined\"!=typeof Proxy&&void 0!==Proxy.revocable&&\"undefined\"!=typeof Reflect,H=W?Symbol.for(\"immer-nothing\"):((G={})[\"immer-nothing\"]=!0,G),L=W?Symbol.for(\"immer-draftable\"):\"__$immer_draftable\",Q=W?Symbol.for(\"immer-state\"):\"__$immer_state\",V=\"undefined\"!=typeof Symbol&&Symbol.iterator||\"@@iterator\",Y={0:\"Illegal state\",1:\"Immer drafts cannot have computed properties\",2:\"This object has been frozen and should not be mutated\",3:function(n){return\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \"+n},4:\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",5:\"Immer forbids circular references\",6:\"The first or second argument to `produce` must be a function\",7:\"The third argument to `produce` must be a function or undefined\",8:\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",9:\"First argument to `finishDraft` must be a draft returned by `createDraft`\",10:\"The given draft is already finalized\",11:\"Object.defineProperty() cannot be used on an Immer draft\",12:\"Object.setPrototypeOf() cannot be used on an Immer draft\",13:\"Immer only supports deleting array indices\",14:\"Immer only supports setting array indices and the 'length' property\",15:function(n){return\"Cannot apply patch, path doesn't resolve: \"+n},16:'Sets cannot have \"replace\" patches.',17:function(n){return\"Unsupported patch operation: \"+n},18:function(n){return\"The plugin for '\"+n+\"' has not been loaded into Immer. To enable the plugin, import and call `enable\"+n+\"()` when initializing your application.\"},20:\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",21:function(n){return\"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\"+n+\"'\"},22:function(n){return\"'current' expects a draft, got: \"+n},23:function(n){return\"'original' expects a draft, got: \"+n}},Z=\"undefined\"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,nn=Object.getOwnPropertyDescriptors||function(n){var t={};return Z(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},tn={},rn={get:function(n,t){if(t===Q)return n;var e=p(n);if(!u(e,t))return function(n,t,r){var e,i=I(t,r);return i?\"value\"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,t);var i=e[t];return n.I||!r(i)?i:i===z(n.t,t)?(k(n),n.o[t]=R(n.A.h,i,n)):i},has:function(n,t){return t in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,t,r){var e=I(p(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.P){var i=z(p(n),t),o=null==i?void 0:i[Q];if(o&&o.t===r)return n.o[t]=r,n.D[t]=!1,!0;if(c(r,i)&&(void 0!==r||u(n.t,t)))return!0;k(n),E(n)}return n.o[t]=r,n.D[t]=!0,!0},deleteProperty:function(n,t){return void 0!==z(n.t,t)||t in n.t?(n.D[t]=!1,k(n),E(n)):delete n.D[t],n.o&&delete n.o[t],!0},getOwnPropertyDescriptor:function(n,t){var r=p(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.i||\"length\"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},en={};i(rn,(function(n,t){en[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),en.deleteProperty=function(t,r){return\"production\"!==process.env.NODE_ENV&&isNaN(parseInt(r))&&n(13),rn.deleteProperty.call(this,t[0],r)},en.set=function(t,r,e){return\"production\"!==process.env.NODE_ENV&&\"length\"!==r&&isNaN(parseInt(r))&&n(14),rn.set.call(this,t[0],r,e,t[0])};var on=function(){function e(n){this.O=B,this.N=\"production\"!==process.env.NODE_ENV,\"boolean\"==typeof(null==n?void 0:n.useProxies)&&this.setUseProxies(n.useProxies),\"boolean\"==typeof(null==n?void 0:n.autoFreeze)&&this.setAutoFreeze(n.autoFreeze),this.produce=this.produce.bind(this),this.produceWithPatches=this.produceWithPatches.bind(this)}var i=e.prototype;return i.produce=function(t,e,i){if(\"function\"==typeof t&&\"function\"!=typeof e){var o=e;e=t;var u=this;return function(n){var t=this;void 0===n&&(n=o);for(var r=arguments.length,i=Array(r>1?r-1:0),a=1;a<r;a++)i[a-1]=arguments[a];return u.produce(n,(function(n){var r;return(r=e).call.apply(r,[t,n].concat(i))}))}}var a;if(\"function\"!=typeof e&&n(6),void 0!==i&&\"function\"!=typeof i&&n(7),r(t)){var f=w(this),c=R(this,t,void 0),s=!0;try{a=e(c),s=!1}finally{s?g(f):O(f)}return\"undefined\"!=typeof Promise&&a instanceof Promise?a.then((function(n){return j(f,i),P(n,f)}),(function(n){throw g(f),n})):(j(f,i),P(a,f))}if(!t||\"object\"!=typeof t){if((a=e(t))===H)return;return void 0===a&&(a=t),this.N&&d(a,!0),a}n(21,t)},i.produceWithPatches=function(n,t){var r,e,i=this;return\"function\"==typeof n?function(t){for(var r=arguments.length,e=Array(r>1?r-1:0),o=1;o<r;o++)e[o-1]=arguments[o];return i.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(e))}))}:[this.produce(n,t,(function(n,t){r=n,e=t})),r,e]},i.createDraft=function(e){r(e)||n(8),t(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,O(i),o},i.finishDraft=function(t,r){var e=t&&t[Q];\"production\"!==process.env.NODE_ENV&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,r),P(void 0,i)},i.setAutoFreeze=function(n){this.N=n},i.setUseProxies=function(t){t&&!B&&n(20),this.O=t},i.applyPatches=function(n,r){var e;for(e=r.length-1;e>=0;e--){var i=r[e];if(0===i.path.length&&\"replace\"===i.op){n=i.value;break}}var o=b(\"Patches\").$;return t(n)?o(n,r):this.produce(n,(function(n){return o(n,r.slice(e+1))}))},e}(),un=new on,an=un.produce,fn=un.produceWithPatches.bind(un),cn=un.setAutoFreeze.bind(un),sn=un.setUseProxies.bind(un),vn=un.applyPatches.bind(un),pn=un.createDraft.bind(un),ln=un.finishDraft.bind(un);export default an;export{on as Immer,vn as applyPatches,K as castDraft,$ as castImmutable,pn as createDraft,D as current,J as enableAllPlugins,T as enableES5,C as enableMapSet,F as enablePatches,ln as finishDraft,L as immerable,t as isDraft,r as isDraftable,H as nothing,e as original,an as produce,fn as produceWithPatches,cn as setAutoFreeze,sn as setUseProxies};\n//# sourceMappingURL=immer.esm.js.map\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var baseGet = require('./_baseGet'),\n    baseSlice = require('./_baseSlice');\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nmodule.exports = parent;\n","var castPath = require('./_castPath'),\n    last = require('./last'),\n    parent = require('./_parent'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = castPath(path, object);\n  object = parent(object, path);\n  return object == null || delete object[toKey(last(path))];\n}\n\nmodule.exports = baseUnset;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var isPlainObject = require('./isPlainObject');\n\n/**\n * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n * objects.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} key The key of the property to inspect.\n * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n */\nfunction customOmitClone(value) {\n  return isPlainObject(value) ? undefined : value;\n}\n\nmodule.exports = customOmitClone;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","var flatten = require('./flatten'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nmodule.exports = flatRest;\n","var arrayMap = require('./_arrayMap'),\n    baseClone = require('./_baseClone'),\n    baseUnset = require('./_baseUnset'),\n    castPath = require('./_castPath'),\n    copyObject = require('./_copyObject'),\n    customOmitClone = require('./_customOmitClone'),\n    flatRest = require('./_flatRest'),\n    getAllKeysIn = require('./_getAllKeysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */\nvar omit = flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = arrayMap(paths, function(path) {\n    path = castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  copyObject(object, getAllKeysIn(object), result);\n  if (isDeep) {\n    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    baseUnset(result, paths[length]);\n  }\n  return result;\n});\n\nmodule.exports = omit;\n","import isPlainObject from 'is-plain-object';\nimport { reverse } from 'esrever';\nimport { produce, createDraft, finishDraft, isDraft } from 'immer';\nimport isEqual from 'lodash/isEqual';\nimport omit from 'lodash/omit';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n    apply: op => {\n      for (var ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op);\n      }\n\n      for (var _ref of Editor.pointRefs(editor)) {\n        PointRef.transform(_ref, op);\n      }\n\n      for (var _ref2 of Editor.rangeRefs(editor)) {\n        RangeRef.transform(_ref2, op);\n      }\n\n      var set = new Set();\n      var dirtyPaths = [];\n\n      var add = path => {\n        if (path) {\n          var key = path.join(',');\n\n          if (!set.has(key)) {\n            set.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var newDirtyPaths = getDirtyPaths(op);\n\n      for (var path of oldDirtyPaths) {\n        var newPath = Path.transform(path, op);\n        add(newPath);\n      }\n\n      for (var _path of newDirtyPaths) {\n        add(_path);\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: (key, value) => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, {\n            [key]: value\n          }, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread(_objectSpread({}, Editor.marks(editor) || {}), {}, {\n            [key]: value\n          });\n\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    },\n    deleteBackward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit\n        });\n      }\n    },\n    deleteFragment: direction => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n          reverse: direction === 'backward'\n        });\n      }\n    },\n    getFragment: () => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: fragment => {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: node => {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: text => {\n      var {\n        selection,\n        marks\n      } = editor;\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          var inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var [, inlinePath] = inline;\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n\n        if (marks) {\n          var node = _objectSpread({\n            text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: entry => {\n      var [node, path] = entry; // There are no core normalizations for text nodes.\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var _child = node.children[i];\n        var prev = node.children[i - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (isLast && _child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: key => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\nvar getDirtyPaths = op => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path2\n        } = op;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref3) => {\n          var [, p] = _ref3;\n          return _path2.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path3\n        } = op;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [...ancestors, previousPath];\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path4,\n          newPath\n        } = op;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        for (var ancestor of Path.ancestors(_path4)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n\n          newAncestors.push(_p);\n        }\n\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [...oldAncestors, ...newAncestors, resultPath];\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path5\n        } = op;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return [..._ancestors];\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path6\n        } = op;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [..._levels, nextPath];\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n/**\r\n * Constants for string distance checking.\r\n */\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\nvar ZERO_WIDTH_JOINER = 0x200d;\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\n\nvar getCharacterDistance = text => {\n  var offset = 0; // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n\n  var prev = null;\n  var charCode = text.charCodeAt(0);\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n\n      if (prev === 'SURR' || prev === 'BMP') {\n        break;\n      }\n\n      offset += 2;\n      prev = modifier ? 'MOD' : 'SURR';\n      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n\n      continue;\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1;\n      prev = 'ZWJ';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'BMP';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'VAR';\n      charCode = text.charCodeAt(offset);\n      continue;\n    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n\n\n    if (prev === 'MOD') {\n      offset += 1;\n      break;\n    } // If while loop ever gets here, we're done (e.g latin chars).\n\n\n    break;\n  }\n\n  return offset || 1;\n};\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\nvar getWordDistance = text => {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char;\n\n  while (char = text.charAt(i)) {\n    var l = getCharacterDistance(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWordCharacter(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = (char, remaining) => {\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharacterDistance(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n\n    if (isWordCharacter(next, rest)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Determines if `code` is a surrogate\r\n */\n\n\nvar isSurrogate = code => SURROGATE_START <= code && code <= SURROGATE_END;\n/**\r\n * Does `code` form Modifier with next one.\r\n *\r\n * https://emojipedia.org/modifiers/\r\n */\n\n\nvar isModifier = (code, text, offset) => {\n  if (code === 0xd83c) {\n    var next = text.charCodeAt(offset + 1);\n    return next <= 0xdfff && next >= 0xdffb;\n  }\n\n  return false;\n};\n/**\r\n * Is `code` a Variation Selector.\r\n *\r\n * https://codepoints.net/variation_selectors\r\n */\n\n\nvar isVariationSelector = code => {\n  return code <= 0xfe0f && code >= 0xfe00;\n};\n/**\r\n * Is `code` one of the BMP codes used in emoji sequences.\r\n *\r\n * https://emojipedia.org/emoji-zwj-sequences/\r\n */\n\n\nvar isBMPEmoji = code => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return code === 0x2764 || // heart ()\n  code === 0x2642 || // male ()\n  code === 0x2640 || // female ()\n  code === 0x2620 || // scull ()\n  code === 0x2695 || // medical ()\n  code === 0x2708 || // plane ()\n  code === 0x25ef // large circle ()\n  ;\n};\n\nvar Element = {\n  /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */\n  isAncestor(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children);\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList(value) {\n    return Array.isArray(value) && value.every(val => Element.isElement(val));\n  },\n\n  /**\r\n   * Check if a set of props is a partial of Element.\r\n   */\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar IS_EDITOR_CACHE = new WeakMap();\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    for (var [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p];\n      }\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {\n      at: range\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {\n      at: range,\n      reverse: true\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      direction = 'forward'\n    } = options;\n    editor.deleteFragment(direction);\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks(editor, element) {\n    return element.children.some(n => Editor.isBlock(editor, n));\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines(editor, element) {\n    return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts(editor, element) {\n    return element.children.every(n => Text.isText(n));\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor(value) {\n    if (!isPlainObject(value)) return false;\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor;\n    }\n\n    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty(editor, element) {\n    var {\n      children\n    } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  *levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (match == null) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var levels = [];\n    var path = Editor.path(editor, at);\n\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue;\n      }\n\n      levels.push([n, p]);\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n\n    if (reverse) {\n      levels.reverse();\n    }\n\n    yield* levels;\n  },\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks(editor) {\n    var {\n      marks,\n      selection\n    } = editor;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var [match] = Editor.nodes(editor, {\n        match: Text.isText\n      });\n\n      if (match) {\n        var [_node] = match;\n\n        var _rest = _objectWithoutProperties(_node, [\"text\"]);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var {\n      anchor\n    } = selection;\n    var {\n      path\n    } = anchor;\n    var [node] = Editor.leaf(editor, path);\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n)\n      });\n\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, [\"text\"]);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids\n    });\n    if (!pointAfterLocation) return;\n    var [, to] = Editor.last(editor, []);\n    var span = [pointAfterLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [next] = Editor.nodes(editor, {\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  *nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (!match) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var from;\n    var to;\n\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    var nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: (_ref) => {\n        var [n] = _ref;\n        return voids ? false : Editor.isVoid(editor, n);\n      }\n    });\n    var matches = [];\n    var hit;\n\n    for (var [node, path] of nodeEntries) {\n      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      } // If there's a match and it's lower than the last, update the hit.\n\n\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n      var emit = mode === 'lowest' ? hit : [node, path];\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n\n      hit = [node, path];\n    } // Since lowest is always emitting one behind, catch up at the end.\n\n\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n\n\n    if (universal) {\n      yield* matches;\n    }\n  },\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      force = false\n    } = options;\n\n    var getDirtyPaths = editor => {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), (_ref2) => {\n        var [, p] = _ref2;\n        return p;\n      });\n      DIRTY_PATHS.set(editor, allPaths);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var dirtyPath = getDirtyPaths(editor).pop(); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n        if (Node.has(editor, dirtyPath)) {\n          var entry = Editor.node(editor, dirtyPath);\n          editor.normalizeNode(entry);\n        }\n\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      depth,\n      edge\n    } = options;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var [, firstPath] = Node.first(editor, at);\n        at = firstPath;\n      } else if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  hasPath(editor, path) {\n    return Node.has(editor, path);\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: path,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      edge = 'start'\n    } = options;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        path = lastPath;\n      } else {\n        var [, firstPath] = Node.first(editor, at);\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: point,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Iterate through all of the positions in the document where a `Point` can be\r\n   * placed.\r\n   *\r\n   * By default it will move forward by individual offsets at a time,  but you\r\n   * can pass the `unit: 'character'` option to moved forward one character, word,\r\n   * or line at at time.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * voids option, then iteration will occur.\r\n   */\n  *positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse: reverse$1 = false,\n      voids = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse$1 ? end : start;\n    var string = '';\n    var available = 0;\n    var offset = 0;\n    var distance = null;\n    var isNewBlock = false;\n\n    var advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string);\n        } else if (unit === 'word') {\n          distance = getWordDistance(string);\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length;\n        } else {\n          distance = 1;\n        }\n\n        string = string.slice(distance);\n      } // Add or substract the offset.\n\n\n      offset = reverse$1 ? offset - distance : offset + distance; // Subtract the distance traveled from the available text.\n\n      available = available - distance; // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n\n      distance = available >= 0 ? null : 0 - available;\n    };\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse: reverse$1,\n      voids\n    })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the voids option is set to true,\n        // then we will iterate over their content\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path);\n          continue;\n        }\n\n        if (editor.isInline(node)) {\n          continue;\n        }\n\n        if (Editor.hasInlines(editor, node)) {\n          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n          var text = Editor.string(editor, {\n            anchor: s,\n            focus: e\n          }, {\n            voids\n          });\n          string = reverse$1 ? reverse(text) : text;\n          isNewBlock = true;\n        }\n      }\n\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path);\n        available = node.text.length;\n        offset = reverse$1 ? available : 0;\n\n        if (isFirst) {\n          available = reverse$1 ? first.offset : available - first.offset;\n          offset = first.offset;\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield {\n            path,\n            offset\n          };\n        }\n\n        while (true) {\n          // If there's no more string and there is no more characters to skip, continue to the next block.\n          if (string === '' && distance === null) {\n            break;\n          } else {\n            advance();\n          } // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n\n\n          if (available >= 0) {\n            yield {\n              path,\n              offset\n            };\n          } else {\n            break;\n          }\n        }\n\n        isNewBlock = false;\n      }\n    }\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids\n    });\n\n    if (!pointBeforeLocation) {\n      return;\n    }\n\n    var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n    // the point before the location passed in\n\n    var span = [pointBeforeLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: range,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */\n  string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var text = '';\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids\n    })) {\n      var t = node.text;\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset);\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset);\n      }\n\n      text += t;\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n)\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, []);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids\n    })) {\n      if (skip) {\n        skip = false;\n        continue;\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = {\n          path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {\n      match: n => Editor.isVoid(editor, n)\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    NORMALIZING.set(editor, false);\n    fn();\n    NORMALIZING.set(editor, value);\n    Editor.normalize(editor);\n  }\n\n};\n\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n\n};\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n\n};\n\nvar IS_NODE_LIST_CACHE = new WeakMap();\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\n  *ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.ancestors(path, options)) {\n      var n = Node.ancestor(root, p);\n      var entry = [n, p];\n      yield entry;\n    }\n  },\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(JSON.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(JSON.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  *children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      reverse = false\n    } = options;\n    var ancestor = Node.ancestor(root, path);\n    var {\n      children\n    } = ancestor;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  *descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  *elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Extract props from a Node.\r\n   */\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, [\"children\"]);\n\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, [\"text\"]);\n\n      return properties;\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(JSON.stringify(root)));\n    }\n\n    var newRoot = produce({\n      children: root.children\n    }, r => {\n      var [start, end] = Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: (_ref) => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(JSON.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(val => Node.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.levels(path, options)) {\n      var n = Node.get(root, p);\n      yield [n, p];\n    }\n  },\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  *nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      pass,\n      reverse = false\n    } = options;\n    var {\n      from = [],\n      to\n    } = options;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't descended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  *texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path];\n      }\n    }\n  }\n\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n\n          if (_properties == null) {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n\n};\n\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n\n  /**\r\n   * Check if the path of previous sibling node exists\r\n   */\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(path, p => {\n      var {\n        affinity = 'forward'\n      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (path.length === 0) {\n        return;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var {\n              path: op\n            } = operation;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var {\n              path: _op\n            } = operation;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var {\n              path: _op2,\n              position\n            } = operation;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var {\n              path: _op3,\n              position: _position\n            } = operation;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ; else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var {\n              path: _op4,\n              newPath: onp\n            } = operation; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                copy[_op4.length - 1] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              } else {\n                p[_op4.length - 1] += 1;\n              }\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(point, p => {\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$3(_objectSpread$3({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, [\"anchor\", \"focus\"]);\n\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$4({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'inward'\n    } = options;\n    var affinityAnchor;\n    var affinityFocus;\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      } else {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      } else {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      }\n    } else {\n      affinityAnchor = affinity;\n      affinityFocus = affinity;\n    }\n\n    return produce(range, r => {\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n\n};\n\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   */\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n    return isEqual(loose ? omit(text, 'text') : text, loose ? omit(another, 'text') : another);\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n\n  /**\r\n   * Check if some props are a partial of Text.\r\n   */\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$5({}, node)];\n\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, [\"anchor\", \"focus\"]);\n\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var o = 0;\n\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var offset = o;\n        o += length; // If the range encompases the entire leaf, add the range.\n\n        if (start.offset <= offset && end.offset >= o) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n        if (start.offset !== end.offset && (start.offset === o || end.offset === offset) || start.offset > o || end.offset < offset || end.offset === offset && offset !== 0) {\n          next.push(leaf);\n          continue;\n        } // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n\n\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n\n        if (end.offset < o) {\n          var off = end.offset - offset;\n          after = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n\n        if (start.offset > offset) {\n          var _off = start.offset - offset;\n\n          before = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n\n        Object.assign(middle, rest);\n\n        if (before) {\n          next.push(before);\n        }\n\n        next.push(middle);\n\n        if (after) {\n          next.push(after);\n        }\n      }\n\n      leaves = next;\n    }\n\n    return leaves;\n  }\n\n};\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    switch (op.type) {\n      case 'insert_node':\n        {\n          var {\n            path,\n            node\n          } = op;\n          var parent = Node.parent(editor, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 0, node);\n\n          if (selection) {\n            for (var [point, key] of Range.points(selection)) {\n              selection[key] = Point.transform(point, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_text':\n        {\n          var {\n            path: _path,\n            offset,\n            text\n          } = op;\n\n          var _node = Node.leaf(editor, _path);\n\n          var before = _node.text.slice(0, offset);\n\n          var after = _node.text.slice(offset);\n\n          _node.text = before + text + after;\n\n          if (selection) {\n            for (var [_point, _key] of Range.points(selection)) {\n              selection[_key] = Point.transform(_point, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var {\n            path: _path2\n          } = op;\n\n          var _node2 = Node.get(editor, _path2);\n\n          var prevPath = Path.previous(_path2);\n          var prev = Node.get(editor, prevPath);\n\n          var _parent = Node.parent(editor, _path2);\n\n          var _index = _path2[_path2.length - 1];\n\n          if (Text.isText(_node2) && Text.isText(prev)) {\n            prev.text += _node2.text;\n          } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n            prev.children.push(..._node2.children);\n          } else {\n            throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(_node2, \" \").concat(prev));\n          }\n\n          _parent.children.splice(_index, 1);\n\n          if (selection) {\n            for (var [_point2, _key2] of Range.points(selection)) {\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var {\n            path: _path3,\n            newPath\n          } = op;\n\n          if (Path.isAncestor(_path3, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n\n          var _node3 = Node.get(editor, _path3);\n\n          var _parent2 = Node.parent(editor, _path3);\n\n          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n\n          _parent2.children.splice(_index2, 1);\n\n          var truePath = Path.transform(_path3, op);\n          var newParent = Node.get(editor, Path.parent(truePath));\n          var newIndex = truePath[truePath.length - 1];\n          newParent.children.splice(newIndex, 0, _node3);\n\n          if (selection) {\n            for (var [_point3, _key3] of Range.points(selection)) {\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var {\n            path: _path4\n          } = op;\n          var _index3 = _path4[_path4.length - 1];\n\n          var _parent3 = Node.parent(editor, _path4);\n\n          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n\n\n          if (selection) {\n            for (var [_point4, _key4] of Range.points(selection)) {\n              var result = Point.transform(_point4, op);\n\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n\n                var next = void 0;\n\n                for (var [n, p] of Node.texts(editor)) {\n                  if (Path.compare(p, _path4) === -1) {\n                    _prev = [n, p];\n                  } else {\n                    next = [n, p];\n                    break;\n                  }\n                }\n\n                if (_prev) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_text':\n        {\n          var {\n            path: _path5,\n            offset: _offset,\n            text: _text\n          } = op;\n\n          var _node4 = Node.leaf(editor, _path5);\n\n          var _before = _node4.text.slice(0, _offset);\n\n          var _after = _node4.text.slice(_offset + _text.length);\n\n          _node4.text = _before + _after;\n\n          if (selection) {\n            for (var [_point5, _key5] of Range.points(selection)) {\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'set_node':\n        {\n          var {\n            path: _path6,\n            newProperties\n          } = op;\n\n          if (_path6.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n\n          var _node5 = Node.get(editor, _path6);\n\n          for (var _key6 in newProperties) {\n            if (_key6 === 'children' || _key6 === 'text') {\n              throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n            }\n\n            var value = newProperties[_key6];\n\n            if (value == null) {\n              delete _node5[_key6];\n            } else {\n              _node5[_key6] = value;\n            }\n          }\n\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var {\n            newProperties: _newProperties\n          } = op;\n\n          if (_newProperties == null) {\n            selection = _newProperties;\n          } else {\n            if (selection == null) {\n              if (!Range.isRange(_newProperties)) {\n                throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties), \" when there is no current selection.\"));\n              }\n\n              selection = _objectSpread$6({}, _newProperties);\n            }\n\n            for (var _key7 in _newProperties) {\n              var _value = _newProperties[_key7];\n\n              if (_value == null) {\n                if (_key7 === 'anchor' || _key7 === 'focus') {\n                  throw new Error(\"Cannot remove the \\\"\".concat(_key7, \"\\\" selection property\"));\n                }\n\n                delete selection[_key7];\n              } else {\n                selection[_key7] = _value;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var {\n            path: _path7,\n            position,\n            properties\n          } = op;\n\n          if (_path7.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n          }\n\n          var _node6 = Node.get(editor, _path7);\n\n          var _parent4 = Node.parent(editor, _path7);\n\n          var _index4 = _path7[_path7.length - 1];\n          var newNode;\n\n          if (Text.isText(_node6)) {\n            var _before2 = _node6.text.slice(0, position);\n\n            var _after2 = _node6.text.slice(position);\n\n            _node6.text = _before2;\n            newNode = _objectSpread$6(_objectSpread$6({}, properties), {}, {\n              text: _after2\n            });\n          } else {\n            var _before3 = _node6.children.slice(0, position);\n\n            var _after3 = _node6.children.slice(position);\n\n            _node6.children = _before3;\n            newNode = _objectSpread$6(_objectSpread$6({}, properties), {}, {\n              children: _after3\n            });\n          }\n\n          _parent4.children.splice(_index4 + 1, 0, newNode);\n\n          if (selection) {\n            for (var [_point6, _key8] of Range.points(selection)) {\n              selection[_key8] = Point.transform(_point6, op);\n            }\n          }\n\n          break;\n        }\n    }\n\n    editor.children = finishDraft(editor.children);\n\n    if (selection) {\n      editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n    } else {\n      editor.selection = null;\n    }\n  }\n\n};\n\nfunction ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at,\n        match,\n        select\n      } = options;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var [node] = nodes; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n);\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n);\n          } else {\n            match = n => Editor.isBlock(editor, n);\n          }\n        }\n\n        var [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids\n        });\n\n        if (entry) {\n          var [, _matchPath] = entry;\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      for (var _node of nodes) {\n        var _path = parentPath.concat(index);\n\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node\n        });\n      }\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, (_ref) => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n        var [parent, parentPath] = parentNodeEntry;\n        var index = path[path.length - 1];\n        var {\n          length\n        } = parent.children;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var [parent] = Editor.parent(editor, at);\n\n          match = n => parent.children.includes(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var [current] = Editor.nodes(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n      var prev = Editor.previous(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var [node, path] = current;\n      var [prevNode, prevPath] = prev;\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), (_ref2) => {\n        var [n] = _ref2;\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"text\"]);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"children\"]);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(JSON.stringify(node), \" \").concat(JSON.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(targets, (_ref3) => {\n        var [, p] = _ref3;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path,\n            newPath\n          });\n        }\n\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(depths, (_ref4) => {\n        var [, p] = _ref4;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path) {\n          var [node] = Editor.node(editor, path);\n          editor.apply({\n            type: 'remove_node',\n            path,\n            node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (split && Range.isRange(at)) {\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        var [start, end] = Range.edges(at);\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      for (var [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      })) {\n        var properties = {};\n        var newProperties = {}; // You can't set properties on the editor node.\n\n        if (path.length === 0) {\n          continue;\n        }\n\n        for (var k in props) {\n          if (k === 'children' || k === 'text') {\n            continue;\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k];\n            newProperties[k] = props[k];\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection,\n        height = 0,\n        always = false\n      } = options;\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n);\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n        var [parent] = Editor.parent(editor, path);\n\n        match = n => n === parent;\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var [highest] = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n\n      if (!highest) {\n        return;\n      }\n\n      var voidMatch = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n\n      if (!voids && voidMatch) {\n        var [voidNode, voidPath] = voidMatch;\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n\n          at = after;\n          always = true;\n        }\n\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n\n      var afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var [, highestPath] = highest;\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n      for (var [node, _path2] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids\n      })) {\n        var split = false;\n\n        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n          break;\n        }\n\n        var _point = beforeRef.current;\n        var isEnd = Editor.isEnd(editor, _point, _path2);\n\n        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n          split = true;\n          var properties = Node.extractProps(node);\n          editor.apply({\n            type: 'split_node',\n            path: _path2,\n            position,\n            properties\n          });\n        }\n\n        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n      }\n\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n\n        Transforms.select(editor, _point2);\n      }\n\n      beforeRef.unref();\n      afterRef.unref();\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    for (var key of props) {\n      obj[key] = null;\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, (_ref5) => {\n        var [, p] = _ref5;\n        return Editor.pathRef(editor, p);\n      });\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n        var [node] = Editor.node(editor, path);\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids\n        });\n      };\n\n      for (var pathRef of pathRefs) {\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var [start, end] = Range.edges(at);\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at,\n        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n        mode: 'lowest',\n        voids\n      }));\n\n      for (var [, rootPath] of roots) {\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n\n        if (matches.length > 0) {\n          (function () {\n            var [first] = matches;\n            var last = matches[matches.length - 1];\n            var [, firstPath] = first;\n            var [, lastPath] = last;\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n            var [commonNode] = commonNodeEntry;\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$7(_objectSpread$7({}, element), {}, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n              to: wrapperPath.concat(0),\n              voids\n            });\n          })();\n        }\n      }\n    });\n  }\n\n};\n\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\n\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\nfunction ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      edge = 'anchor'\n    } = options;\n    var {\n      selection\n    } = editor;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var [start] = Range.edges(selection);\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var [, end] = Range.edges(selection);\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      distance = 1,\n      unit = 'character',\n      reverse = false\n    } = options;\n    var {\n      edge = null\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var opts = {\n      distance,\n      unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select(editor, target) {\n    var {\n      selection\n    } = editor;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(JSON.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      edge = 'both'\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$8(_objectSpread$8({}, point), props)\n    });\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection(editor, props) {\n    var {\n      selection\n    } = editor;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n\n};\n\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        hanging = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var [, voidPath] = furthestVoid;\n          at = voidPath;\n        } else {\n          var opts = {\n            unit,\n            distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at,\n          voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        var [, _end] = Range.edges(at);\n        var endOfDoc = Editor.end(editor, []);\n\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids\n          });\n        }\n      }\n\n      var [start, end] = Range.edges(at);\n      var startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      for (var entry of Editor.nodes(editor, {\n        at,\n        voids\n      })) {\n        var [node, path] = entry;\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue;\n        }\n\n        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n          matches.push(entry);\n          lastPath = path;\n        }\n      }\n\n      var pathRefs = Array.from(matches, (_ref) => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n        var [_node] = Editor.leaf(editor, _point);\n        var {\n          path: _path\n        } = _point;\n        var {\n          offset\n        } = start;\n\n        var text = _node.text.slice(offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset,\n          text\n        });\n      }\n\n      for (var pathRef of pathRefs) {\n        var _path2 = pathRef.unref();\n\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n        var [_node2] = Editor.leaf(editor, _point2);\n        var {\n          path: _path3\n        } = _point2;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path3,\n          offset: _offset,\n          text: _text\n        });\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids\n        });\n      }\n\n      var point = reverse ? startRef.unref() || endRef.unref() : endRef.unref() || startRef.unref();\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (inlineElementMatch) {\n        var [, _inlinePath] = inlineElementMatch;\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids\n      });\n      var [, blockPath] = blockMatch;\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n      var [, firstPath] = Node.first({\n        children: fragment\n      }, []);\n      var [, lastPath] = Node.last({\n        children: fragment\n      }, []);\n      var matches = [];\n\n      var matcher = (_ref2) => {\n        var [n, p] = _ref2;\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      for (var entry of Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n      var [, inlinePath] = inlineMatch;\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at,\n        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current);\n        } else {\n          path = Path.previous(startRef.current);\n        }\n\n        var _end2 = Editor.end(editor, path);\n\n        Transforms.select(editor, _end2);\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          at = pointRef.unref();\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      }\n\n      var {\n        path,\n        offset\n      } = at;\n      editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n\n};\n\nfunction ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\nexport { Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, Transforms, createEditor };\n//# sourceMappingURL=index.es.js.map\n","'use strict'\n\nmodule.exports = direction\n\nvar RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nvar LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\nvar rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\nvar ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nfunction direction(value) {\n  value = String(value || '')\n\n  if (rtl.test(value)) {\n    return 'rtl'\n  }\n\n  if (ltr.test(value)) {\n    return 'ltr'\n  }\n\n  return 'neutral'\n}\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","function isElement(el) {\n  return el != null && typeof el === 'object' && el.nodeType === 1;\n}\n\nfunction canOverflow(overflow, skipOverflowHiddenElements) {\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\n    return false;\n  }\n\n  return overflow !== 'visible' && overflow !== 'clip';\n}\n\nfunction getFrameElement(el) {\n  if (!el.ownerDocument || !el.ownerDocument.defaultView) {\n    return null;\n  }\n\n  return el.ownerDocument.defaultView.frameElement;\n}\n\nfunction isHiddenByFrame(el) {\n  var frame = getFrameElement(el);\n\n  if (!frame) {\n    return false;\n  }\n\n  return frame.clientHeight < el.scrollHeight || frame.clientWidth < el.scrollWidth;\n}\n\nfunction isScrollable(el, skipOverflowHiddenElements) {\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\n    var style = getComputedStyle(el, null);\n    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements) || isHiddenByFrame(el);\n  }\n\n  return false;\n}\n\nfunction alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\n    return 0;\n  }\n\n  if (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize || elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize) {\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n  }\n\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n  }\n\n  return 0;\n}\n\nexport default (function (target, options) {\n  var scrollMode = options.scrollMode,\n      block = options.block,\n      inline = options.inline,\n      boundary = options.boundary,\n      skipOverflowHiddenElements = options.skipOverflowHiddenElements;\n  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {\n    return node !== boundary;\n  };\n\n  if (!isElement(target)) {\n    throw new TypeError('Invalid target');\n  }\n\n  var scrollingElement = document.scrollingElement || document.documentElement;\n  var frames = [];\n  var cursor = target;\n\n  while (isElement(cursor) && checkBoundary(cursor)) {\n    cursor = cursor.parentNode;\n\n    if (cursor === scrollingElement) {\n      frames.push(cursor);\n      break;\n    }\n\n    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {\n      continue;\n    }\n\n    if (isScrollable(cursor, skipOverflowHiddenElements)) {\n      frames.push(cursor);\n    }\n  }\n\n  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;\n  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;\n  var viewportX = window.scrollX || pageXOffset;\n  var viewportY = window.scrollY || pageYOffset;\n\n  var _target$getBoundingCl = target.getBoundingClientRect(),\n      targetHeight = _target$getBoundingCl.height,\n      targetWidth = _target$getBoundingCl.width,\n      targetTop = _target$getBoundingCl.top,\n      targetRight = _target$getBoundingCl.right,\n      targetBottom = _target$getBoundingCl.bottom,\n      targetLeft = _target$getBoundingCl.left;\n\n  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;\n  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;\n  var computations = [];\n\n  for (var index = 0; index < frames.length; index++) {\n    var frame = frames[index];\n\n    var _frame$getBoundingCli = frame.getBoundingClientRect(),\n        height = _frame$getBoundingCli.height,\n        width = _frame$getBoundingCli.width,\n        top = _frame$getBoundingCli.top,\n        right = _frame$getBoundingCli.right,\n        bottom = _frame$getBoundingCli.bottom,\n        left = _frame$getBoundingCli.left;\n\n    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= top && targetBottom <= bottom && targetLeft >= left && targetRight <= right) {\n      return computations;\n    }\n\n    var frameStyle = getComputedStyle(frame);\n    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\n    var borderTop = parseInt(frameStyle.borderTopWidth, 10);\n    var borderRight = parseInt(frameStyle.borderRightWidth, 10);\n    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\n    var blockScroll = 0;\n    var inlineScroll = 0;\n    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;\n    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;\n\n    if (scrollingElement === frame) {\n      if (block === 'start') {\n        blockScroll = targetBlock;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - viewportHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - viewportHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - viewportWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - viewportWidth;\n      } else {\n        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\n      }\n\n      blockScroll = Math.max(0, blockScroll + viewportY);\n      inlineScroll = Math.max(0, inlineScroll + viewportX);\n    } else {\n      if (block === 'start') {\n        blockScroll = targetBlock - top - borderTop;\n      } else if (block === 'end') {\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n      } else if (block === 'nearest') {\n        blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\n      } else {\n        blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;\n      }\n\n      if (inline === 'start') {\n        inlineScroll = targetInline - left - borderLeft;\n      } else if (inline === 'center') {\n        inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;\n      } else if (inline === 'end') {\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth;\n      } else {\n        inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\n      }\n\n      var scrollLeft = frame.scrollLeft,\n          scrollTop = frame.scrollTop;\n      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - height + scrollbarHeight));\n      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - width + scrollbarWidth));\n      targetBlock += scrollTop - blockScroll;\n      targetInline += scrollLeft - inlineScroll;\n    }\n\n    computations.push({\n      el: frame,\n      top: blockScroll,\n      left: inlineScroll\n    });\n  }\n\n  return computations;\n});","import compute from 'compute-scroll-into-view';\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\n\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n\n  var canSmoothScroll = 'scrollBehavior' in document.body.style;\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n        top = _ref.top,\n        left = _ref.left;\n\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\n\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n\n  if (isOptionsObject(options)) {\n    return options;\n  }\n\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\n\nfunction scrollIntoView(target, options) {\n  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);\n\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(targetIsDetached ? [] : compute(target, options));\n  }\n\n  if (targetIsDetached) {\n    return;\n  }\n\n  var computeOptions = getOptions(options);\n  return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);\n}\n\nexport default scrollIntoView;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\nexports.default = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nexport default invariant;\n","import React, { useRef, useEffect, useLayoutEffect, useContext, createContext, useMemo, useCallback, useState } from 'react';\nimport { Editor, Operation, Path, Node, Text as Text$1, Range, Element as Element$1, Transforms } from 'slate';\nimport getDirection from 'direction';\nimport isPlainObject from 'is-plain-object';\nimport throttle from 'lodash/throttle';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport { isKeyHotkey } from 'is-hotkey';\nimport invariant from 'tiny-invariant';\nimport ReactDOM from 'react-dom';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));\n  }\n\n};\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor(value) {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n\n  /**\r\n   * Redo to the previous saved state.\r\n   */\n  redo(editor) {\n    editor.redo();\n  },\n\n  /**\r\n   * Undo to the previous saved state.\r\n   */\n  undo(editor) {\n    editor.undo();\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n\n};\n\n/**\r\n * Leaf content strings.\r\n */\n\nvar String = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = Path.parent(path); // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      length: Node.string(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isLineBreak: true\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n\n  if (leaf.text === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, null);\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/React.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\n\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-string\": true\n  }, text, isTrailing ? '\\n' : null);\n};\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\n\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false\n  } = props;\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-zero-width\": isLineBreak ? 'n' : 'z',\n    \"data-slate-length\": length\n  }, '\\uFEFF', isLineBreak ? /*#__PURE__*/React.createElement(\"br\", null) : null);\n};\n\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar KEY_TO_ELEMENT = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */\n\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\n\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderLeaf = props => /*#__PURE__*/React.createElement(DefaultLeaf, Object.assign({}, props))\n  } = props;\n  var placeholderRef = useRef(null);\n  useEffect(() => {\n    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;\n    var editorEl = document.querySelector('[data-slate-editor=\"true\"]');\n\n    if (!placeholderEl || !editorEl) {\n      return;\n    }\n\n    editorEl.style.minHeight = \"\".concat(placeholderEl.clientHeight, \"px\");\n    return () => {\n      editorEl.style.minHeight = 'auto';\n    };\n  }, [placeholderRef]);\n  var children = /*#__PURE__*/React.createElement(String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n\n  if (leaf[PLACEHOLDER_SYMBOL]) {\n    children = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"span\", {\n      ref: placeholderRef,\n      contentEditable: false,\n      style: {\n        pointerEvents: 'none',\n        display: 'inline-block',\n        width: '100%',\n        maxWidth: '100%',\n        whiteSpace: 'nowrap',\n        opacity: '0.333',\n        userSelect: 'none',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n        textDecoration: 'none',\n        position: 'absolute'\n      }\n    }, leaf.placeholder), children);\n  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text\n  });\n};\n\nvar MemoizedLeaf = /*#__PURE__*/React.memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && next.leaf.text === prev.leaf.text && Text$1.matches(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/React.createElement(\"span\", Object.assign({}, attributes), children);\n};\n\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\n\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\n\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\n\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])).*/i.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\n\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */\n\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isDecoratorRangeListEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n\n    var rangeOwnProps = _objectWithoutProperties(range, [\"anchor\", \"focus\"]);\n\n    var otherOwnProps = _objectWithoutProperties(other, [\"anchor\", \"focus\"]);\n\n    if (!Range.equals(range, other) || range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] || !shallowCompare(rangeOwnProps, otherOwnProps)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\r\n * Text.\r\n */\n\nvar Text = props => {\n  var {\n    decorations,\n    isLast,\n    parent,\n    renderLeaf,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = useRef(null);\n  var leaves = Text$1.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/React.createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(text, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, text);\n    } else {\n      KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: ref\n  }, children);\n};\n\nvar MemoizedText = /*#__PURE__*/React.memo(Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && isDecoratorRangeListEqual(next.decorations, prev.decorations);\n});\n\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = () => {\n  return useContext(SelectedContext);\n};\n\n/**\r\n * Element.\r\n */\n\nvar Element = props => {\n  var {\n    decorations,\n    element,\n    renderElement = p => /*#__PURE__*/React.createElement(DefaultElement, Object.assign({}, p)),\n    renderLeaf,\n    selection\n  } = props;\n  var ref = useRef(null);\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderLeaf,\n    selection\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    var text = Node.string(element);\n    var dir = getDirection(text);\n\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = Node.texts(element);\n    children = readOnly ? null : /*#__PURE__*/React.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/React.createElement(MemoizedText, {\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(element, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, element);\n    } else {\n      KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  });\n  return /*#__PURE__*/React.createElement(SelectedContext.Provider, {\n    value: !!selection\n  }, renderElement({\n    attributes,\n    children,\n    element\n  }));\n};\n\nvar MemoizedElement = /*#__PURE__*/React.memo(Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isDecoratorRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/React.createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\r\n * A React context for sharing the editor object.\r\n */\n\nvar EditorContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlateStatic = () => {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */\n\nvar DecorateContext = /*#__PURE__*/createContext(() => []);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */\n\nvar useDecorate = () => {\n  return useContext(DecorateContext);\n};\n\n/**\r\n * Children.\r\n */\n\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element$1.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = Editor.range(editor, p);\n    var sel = selection && Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n\n    for (var dec of decorations) {\n      var d = Range.intersection(dec, range);\n\n      if (d) {\n        ds.push(d);\n      }\n    }\n\n    if (Element$1.isElement(n)) {\n      children.push( /*#__PURE__*/React.createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderLeaf: renderLeaf,\n        selection: sel\n      }));\n    } else {\n      children.push( /*#__PURE__*/React.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n\n  return children;\n};\n\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  splitBlock: 'shift?+enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isKeyHotkey(generic);\n  var isApple = apple && isKeyHotkey(apple);\n  var isWindows = windows && isKeyHotkey(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = () => {\n  return useContext(ReadOnlyContext);\n};\n\n/**\r\n * A React context for sharing the editor object, in a way that re-renders the\r\n * context whenever changes occur.\r\n */\n\nvar SlateContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlate = () => {\n  var context = useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <SlateProvider> component's context.\");\n  }\n\n  var [editor] = context;\n  return editor;\n};\n\n/**\r\n * Types.\r\n */\n/**\r\n * Returns the host window of a DOM node\r\n */\n\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */\n\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */\n\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward'); // If the editable child found is in front of input offset, we instead seek to its end\n\n    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return [node, offset];\n};\n/**\r\n * Determines wether the active element is nested within a shadowRoot\r\n */\n\nvar hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot);\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n\n  return [child, index];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */\n\nvar getPlainText = domNode => {\n  var text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n// Chrome Legacy doesn't support `beforeinput` correctly\n\nvar HAS_BEFORE_INPUT_SUPPORT = !(IS_FIREFOX_LEGACY || IS_EDGE_LEGACY || IS_CHROME_LEGACY);\n/**\r\n * Editable.\r\n */\n\nvar Editable = props => {\n  var {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    style = {},\n    as: Component = 'div'\n  } = props,\n      attributes = _objectWithoutProperties(props, [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"style\", \"as\"]);\n\n  var editor = useSlate();\n  var ref = useRef(null); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = useMemo(() => ({\n    isComposing: false,\n    isUpdatingSelection: false,\n    latestElement: null\n  }), []); // Update element-related weak maps with the DOM element ref.\n\n  useIsomorphicLayoutEffect(() => {\n    var window;\n\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    }\n  }); // Whenever the editor updates, make sure the DOM selection state is in sync.\n\n  useIsomorphicLayoutEffect(() => {\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {\n      return;\n    }\n\n    var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n    if (!selection && !hasDomSelection) {\n      return;\n    } // verify that the dom selection is in the editor\n\n\n    var editorElement = EDITOR_TO_ELEMENT.get(editor);\n    var hasDomSelectionInEditor = false;\n\n    if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n      hasDomSelectionInEditor = true;\n    } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n\n\n    if (hasDomSelection && hasDomSelectionInEditor && selection && Range.equals(ReactEditor.toSlateRange(editor, domSelection), selection)) {\n      return;\n    } // when <Editable/> is being controlled through external value\n    // then its children might just change - DOM responds to it on its own\n    // but Slate's value is not being updated through any operation\n    // and thus it doesn't transform selection on its own\n\n\n    if (selection && !ReactEditor.hasRange(editor, selection)) {\n      editor.selection = ReactEditor.toSlateRange(editor, domSelection);\n      return;\n    } // Otherwise the DOM selection is out of sync, so update it.\n\n\n    var el = ReactEditor.toDOMNode(editor, editor);\n    state.isUpdatingSelection = true;\n    var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n\n    if (newDomRange) {\n      if (Range.isBackward(selection)) {\n        domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n      } else {\n        domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n      }\n\n      var leafEl = newDomRange.startContainer.parentElement;\n      leafEl.getBoundingClientRect = newDomRange.getBoundingClientRect.bind(newDomRange);\n      scrollIntoView(leafEl, {\n        scrollMode: 'if-needed',\n        boundary: el\n      });\n      delete leafEl.getBoundingClientRect;\n    } else {\n      domSelection.removeAllRanges();\n    }\n\n    setTimeout(() => {\n      // COMPAT: In Firefox, it's not enough to create a range, you also need\n      // to focus the contenteditable element too. (2016/11/16)\n      if (newDomRange && IS_FIREFOX) {\n        el.focus();\n      }\n\n      state.isUpdatingSelection = false;\n    });\n  }); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n\n  useEffect(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = useCallback(event => {\n    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined; // These two types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n      if (type === 'insertCompositionText' || type === 'deleteCompositionText') {\n        return;\n      }\n\n      event.preventDefault(); // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var [targetRange] = event.getTargetRanges();\n\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange);\n\n          if (!selection || !Range.equals(selection, range)) {\n            Transforms.select(editor, range);\n          }\n        }\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n\n      if (selection && Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            Editor.deleteFragment(editor);\n            break;\n          }\n\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            Editor.deleteForward(editor);\n            break;\n          }\n\n        case 'deleteContentBackward':\n          {\n            Editor.deleteBackward(editor);\n            break;\n          }\n\n        case 'deleteEntireSoftLine':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteWordBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'deleteWordForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'insertLineBreak':\n        case 'insertParagraph':\n          {\n            Editor.insertBreak(editor);\n            break;\n          }\n\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              state.isComposing = false;\n            }\n\n            var window = ReactEditor.getWindow(editor);\n\n            if (data instanceof window.DataTransfer) {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              Editor.insertText(editor, data);\n            }\n\n            break;\n          }\n      }\n    }\n  }, [readOnly, propsOnDOMBeforeInput]); // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  // https://github.com/facebook/react/issues/11211\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n      // @ts-ignore The `beforeinput` event isn't recognized.\n      ref.current.addEventListener('beforeinput', onDOMBeforeInput);\n    }\n\n    return () => {\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    };\n  }, [onDOMBeforeInput]); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = useCallback(throttle(() => {\n    if (!readOnly && !state.isComposing && !state.isUpdatingSelection) {\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = root;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = root.getSelection();\n\n      if (activeElement === el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n\n      if (!domSelection) {\n        return Transforms.deselect(editor);\n      }\n\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideVoid(editor, anchorNode);\n      var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideVoid(editor, focusNode);\n\n      if (anchorNodeSelectable && focusNodeSelectable) {\n        var range = ReactEditor.toSlateRange(editor, domSelection);\n        Transforms.select(editor, range);\n      } else {\n        Transforms.deselect(editor);\n      }\n    }\n  }, 100), [readOnly]); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    window.document.addEventListener('selectionchange', onDOMSelectionChange);\n    return () => {\n      window.document.removeEventListener('selectionchange', onDOMSelectionChange);\n    };\n  }, [onDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n\n  if (placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '') {\n    var start = Editor.start(editor, []);\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start,\n      focus: start\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/React.createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/React.createElement(Component // COMPAT: The Grammarly Chrome extension works by changing the DOM\n  // out from under `contenteditable` elements, which leads to weird\n  // behaviors so we have to disable it like editor. (2017/04/24)\n  , Object.assign({\n    \"data-gramm\": false,\n    role: readOnly ? undefined : 'textbox'\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    spellCheck: !HAS_BEFORE_INPUT_SUPPORT ? false : attributes.spellCheck,\n    autoCorrect: !HAS_BEFORE_INPUT_SUPPORT ? false : attributes.autoCorrect,\n    autoCapitalize: !HAS_BEFORE_INPUT_SUPPORT ? false : attributes.autoCapitalize,\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    contentEditable: readOnly ? undefined : true,\n    suppressContentEditableWarning: true,\n    ref: ref,\n    style: _objectSpread({\n      // Allow positioning relative to the editable element.\n      position: 'relative',\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, style),\n    onBeforeInput: useCallback(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && hasEditableTarget(editor, event.target)) {\n        event.preventDefault();\n\n        if (!state.isComposing) {\n          var text = event.data;\n          Editor.insertText(editor, text);\n        }\n      }\n    }, [readOnly]),\n    onBlur: useCallback(event => {\n      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      }\n\n      var window = ReactEditor.getWindow(editor); // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n\n        if (Element$1.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      }\n\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, attributes.onBlur]),\n    onClick: useCallback(event => {\n      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n\n        var _start = Editor.start(editor, path);\n\n        var end = Editor.end(editor, path);\n        var startVoid = Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = Editor.void(editor, {\n          at: end\n        });\n\n        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {\n          var range = Editor.range(editor, _start);\n          Transforms.select(editor, range);\n        }\n      }\n    }, [readOnly, attributes.onClick]),\n    onCompositionEnd: useCallback(event => {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {\n        state.isComposing = false; // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n        if (!IS_SAFARI && !IS_FIREFOX && event.data) {\n          Editor.insertText(editor, event.data);\n        }\n      }\n    }, [attributes.onCompositionEnd]),\n    onCompositionUpdate: useCallback(event => {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        state.isComposing = true;\n      }\n    }, [attributes.onCompositionUpdate]),\n    onCompositionStart: useCallback(event => {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {\n        var {\n          selection\n        } = editor;\n\n        if (selection && Range.isExpanded(selection)) {\n          Editor.deleteFragment(editor);\n        }\n      }\n    }, [attributes.onCompositionStart]),\n    onCopy: useCallback(event => {\n      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData);\n      }\n    }, [attributes.onCopy]),\n    onCut: useCallback(event => {\n      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData);\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n          } else {\n            var node = Node.parent(editor, selection.anchor.path);\n\n            if (Editor.isVoid(editor, node)) {\n              Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onCut]),\n    onDragOver: useCallback(event => {\n      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n\n        if (Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver]),\n    onDragStart: useCallback(event => {\n      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Editor.void(editor, {\n          at: path\n        }); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Transforms.select(editor, range);\n        }\n\n        ReactEditor.setFragmentData(editor, event.dataTransfer);\n      }\n    }, [attributes.onDragStart]),\n    onDrop: useCallback(event => {\n      if (hasTarget(editor, event.target) && !readOnly && !isEventHandled(event, attributes.onDrop)) {\n        // COMPAT: Certain browsers don't fire `beforeinput` events at all, and\n        // Chromium browsers don't properly fire them for files being\n        // dropped into a `contenteditable`. (2019/11/26)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1028668\n        if (!HAS_BEFORE_INPUT_SUPPORT || !IS_SAFARI && event.dataTransfer.files.length > 0) {\n          event.preventDefault();\n          var range = ReactEditor.findEventRange(editor, event);\n          var data = event.dataTransfer;\n          Transforms.select(editor, range);\n          ReactEditor.insertData(editor, data);\n        }\n      }\n    }, [readOnly, attributes.onDrop]),\n    onFocus: useCallback(event => {\n      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, attributes.onFocus]),\n    onKeyDown: useCallback(event => {\n      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onKeyDown)) {\n        var {\n          nativeEvent\n        } = event;\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = getDirection(Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n\n          if (HistoryEditor.isHistoryEditor(editor)) {\n            editor.redo();\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n\n          if (HistoryEditor.isHistoryEditor(editor)) {\n            editor.undo();\n          }\n\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'start'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'end'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n        }\n      }\n    }, [readOnly, attributes.onKeyDown]),\n    onPaste: useCallback(event => {\n      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, attributes.onPaste])\n  }), useChildren({\n    decorations,\n    node: editor,\n    renderElement,\n    renderLeaf,\n    selection: editor.selection\n  }))));\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\nvar defaultDecorate = () => [];\n/**\r\n * Check if the target is in the editor.\r\n */\n\n\nvar hasTarget = (editor, target) => {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n};\n/**\r\n * Check if the target is editable and in the editor.\r\n */\n\n\nvar hasEditableTarget = (editor, target) => {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n    editable: true\n  });\n};\n/**\r\n * Check if the target is inside void and in the editor.\r\n */\n\n\nvar isTargetInsideVoid = (editor, target) => {\n  var slateNode = hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n  return Editor.isVoid(editor, slateNode);\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\n\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n\n  handler(event);\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\n\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n\n  handler(event);\n  return event.defaultPrevented;\n};\n\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\nvar n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\n\nclass Key {\n  constructor() {\n    this.id = \"\".concat(n++);\n  }\n\n}\n\nvar ReactEditor = {\n  /**\r\n   * Return the host window of the current editor.\r\n   */\n  getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n\n    return window;\n  },\n\n  /**\r\n   * Find a key for a Slate node.\r\n   */\n  findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n\n    return key;\n  },\n\n  /**\r\n   * Find the path of Slate node.\r\n   */\n  findPath(editor, node) {\n    var path = [];\n    var child = node;\n\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n\n      var i = NODE_TO_INDEX.get(child);\n\n      if (i == null) {\n        break;\n      }\n\n      path.unshift(i);\n      child = parent;\n    }\n\n    throw new Error(\"Unable to find the path for Slate node: \".concat(JSON.stringify(node)));\n  },\n\n  /**\r\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\r\n   */\n  findDocumentOrShadowRoot(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (!(root instanceof Document || root instanceof ShadowRoot)) throw new Error(\"Unable to find DocumentOrShadowRoot for editor element: \".concat(el)); // COMPAT: Only Chrome implements the DocumentOrShadowRoot mixin for\n    // ShadowRoot; other browsers still implement it on the Document\n    // interface. (2020/08/08)\n    // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot#Properties\n\n    if (root.getSelection === undefined && el.ownerDocument !== null) return el.ownerDocument;\n    return root;\n  },\n\n  /**\r\n   * Check if the editor is focused.\r\n   */\n  isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n\n  /**\r\n   * Check if the editor is in read-only mode.\r\n   */\n  isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n\n  /**\r\n   * Blur the editor.\r\n   */\n  blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n\n  /**\r\n   * Focus the editor.\r\n   */\n  focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n\n    if (root.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n\n  /**\r\n   * Deselect the editor.\r\n   */\n  deselect(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n\n  /**\r\n   * Check if a DOM node is within the editor.\r\n   */\n  hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n\n    if (!targetEl) {\n      return false;\n    }\n\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n\n  /**\r\n   * Insert data from a `DataTransfer` into the editor.\r\n   */\n  insertData(editor, data) {\n    editor.insertData(data);\n  },\n\n  /**\r\n   * Sets data from the currently selected fragment on a `DataTransfer`.\r\n   */\n  setFragmentData(editor, data) {\n    editor.setFragmentData(data);\n  },\n\n  /**\r\n   * Find the native DOM element from a Slate node.\r\n   */\n  toDOMNode(editor, node) {\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(JSON.stringify(node)));\n    }\n\n    return domNode;\n  },\n\n  /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */\n  toDOMPoint(editor, point) {\n    var [node] = Editor.node(editor, point.path);\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n\n    if (Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    } // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n\n    for (var text of texts) {\n      var domNode = text.childNodes[0];\n\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n\n      start = end;\n    }\n\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(JSON.stringify(point)));\n    }\n\n    return domPoint;\n  },\n\n  /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   *\r\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\r\n   *\r\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\r\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\r\n   */\n  toDOMRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window = ReactEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n\n  /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */\n  toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Get the target range from a DOM `event`.\r\n   */\n  findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n\n      if (point) {\n        var _range = Editor.range(editor, point);\n\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var domRange;\n    var {\n      document\n    } = window; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = ReactEditor.toSlateRange(editor, domRange);\n    return range;\n  },\n\n  /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */\n  toSlatePoint(editor, domPoint) {\n    var [nearestNode, nearestOffset] = normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n\n    if (parentNode) {\n      var voidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n\n        var _window = ReactEditor.getWindow(editor);\n\n        var range = _window.document.createRange();\n\n        range.setStart(textNode, 0);\n        range.setEnd(nearestNode, nearestOffset);\n        var contents = range.cloneContents();\n        var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n        removals.forEach(el => {\n          el.parentNode.removeChild(el);\n        }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n        // convert \\n into \\r\\n. The bug causes a loop when slate-react\n        // attempts to reposition its cursor to match the native position. Use\n        // textContent.length instead.\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n        offset = contents.textContent.length;\n        domNode = textNode;\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n        leafNode = voidNode.querySelector('[data-slate-leaf]'); // COMPAT: In read-only editors the leaf is not rendered.\n\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      } // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n\n\n      if (domNode && offset === domNode.textContent.length && parentNode.hasAttribute('data-slate-zero-width')) {\n        offset--;\n      }\n    }\n\n    if (!textNode) {\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n\n  /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */\n  toSlateRange(editor, domRange) {\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode;\n        anchorOffset = domRange.anchorOffset;\n        focusNode = domRange.focusNode;\n        focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset]);\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset]);\n    return {\n      anchor,\n      focus\n    };\n  },\n\n  hasRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  }\n\n};\n\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = () => {\n  return useContext(FocusedContext);\n};\n\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = props => {\n  var {\n    editor,\n    children,\n    onChange,\n    value\n  } = props,\n      rest = _objectWithoutProperties(props, [\"editor\", \"children\", \"onChange\", \"value\"]);\n\n  var [key, setKey] = useState(0);\n  var context = useMemo(() => {\n    invariant(Node.isNodeList(value), \"[Slate] value is invalid! Expected a list of elements but got: \".concat(JSON.stringify(value)));\n    invariant(Editor.isEditor(editor), \"[Slate] editor is invalid! you passed: \".concat(JSON.stringify(editor)));\n    editor.children = value;\n    Object.assign(editor, rest);\n    return [editor];\n  }, [key, value, ...Object.values(rest)]);\n  var onContextChange = useCallback(() => {\n    onChange(editor.children);\n    setKey(key + 1);\n  }, [key, onChange]);\n  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n  useEffect(() => {\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {});\n    };\n  }, []);\n  var [isFocused, setIsFocused] = useState(ReactEditor.isFocused(editor));\n  useEffect(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  });\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n\n    document.addEventListener('focus', fn, true);\n    return () => document.removeEventListener('focus', fn, true);\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n\n    document.addEventListener('blur', fn, true);\n    return () => document.removeEventListener('blur', fn, true);\n  }, []);\n  return /*#__PURE__*/React.createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(EditorContext.Provider, {\n    value: editor\n  }, /*#__PURE__*/React.createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children)));\n};\n\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */\n\nvar useEditor = () => {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Utilities for single-line deletion\r\n */\n\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\n\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */\n\n\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n\n    middle = Math.floor((left + right) / 2);\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withReact = editor => {\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward\n  } = e;\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n\n    if (editor.selection && Range.isCollapsed(editor.selection)) {\n      var parentBlockEntry = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: editor.selection\n      });\n\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = Editor.range(editor, parentBlockPath, editor.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(editor, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n\n  e.apply = op => {\n    var matches = [];\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n        {\n          for (var [node, path] of Editor.levels(e, {\n            at: op.path\n          })) {\n            var key = ReactEditor.findKey(e, node);\n            matches.push([path, key]);\n          }\n\n          break;\n        }\n\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n        {\n          for (var [_node, _path] of Editor.levels(e, {\n            at: Path.parent(op.path)\n          })) {\n            var _key = ReactEditor.findKey(e, _node);\n\n            matches.push([_path, _key]);\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          for (var [_node2, _path2] of Editor.levels(e, {\n            at: Path.common(Path.parent(op.path), Path.parent(op.newPath))\n          })) {\n            var _key2 = ReactEditor.findKey(e, _node2);\n\n            matches.push([_path2, _key2]);\n          }\n\n          break;\n        }\n    }\n\n    apply(op);\n\n    for (var [_path3, _key3] of matches) {\n      var [_node3] = Editor.node(e, _path3);\n      NODE_TO_KEY.set(_node3, _key3);\n    }\n  };\n\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n\n    if (!selection) {\n      return;\n    }\n\n    var [start, end] = Range.edges(selection);\n    var startVoid = Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = Editor.void(e, {\n      at: end.path\n    });\n\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return;\n    } // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n\n\n    var domRange = ReactEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    }); // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    } // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n\n\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    } // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n\n\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n    if (isDOMText(attach)) {\n      var span = document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n    var div = document.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    document.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    document.body.removeChild(div);\n  };\n\n  e.insertData = data => {\n    var fragment = data.getData('application/x-slate-fragment');\n\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return;\n    }\n\n    var text = data.getData('text/plain');\n\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n\n      for (var line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n\n        e.insertText(line);\n        split = true;\n      }\n    }\n  };\n\n  e.onChange = () => {\n    // COMPAT: React doesn't batch `setState` hook calls, which means that the\n    // children and selection can get out of sync for one render pass. So we\n    // have to use this unstable API to ensure it batches them. (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    ReactDOM.unstable_batchedUpdates(() => {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n\n      if (onContextChange) {\n        onContextChange();\n      }\n\n      onChange();\n    });\n  };\n\n  return e;\n};\n\nexport { DefaultElement, DefaultLeaf, Editable, ReactEditor, Slate, useEditor, useFocused, useReadOnly, useSelected, useSlate, useSlateStatic, withReact };\n//# sourceMappingURL=index.es.js.map\n","export default (href, { addHttps } = {}) => {\n  let clean = href || '';\n\n  // convert to lowercase\n  clean = clean.toLowerCase();\n\n  if (addHttps) {\n    // if no http(s), add it to the\n    if (!clean.match(/(http(s?)):\\/\\//gi)) return `https://${clean}`;\n    return clean;\n  }\n\n  // if https(s) found, just return\n  return clean;\n}\n","export default (href = '') => {\n\n  // return null if not applicable\n  if (!href || typeof href !== 'string') return null;\n\n  // make lowercase\n  const clean = href.toLowerCase();\n\n  // apply this crazy regex from stackoverflow\n  return !!clean.match(/^(?:(?:(?:https?|ftp):)?\\/\\/)?(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i)\n}\n","// checks if the currently element with focus\n// has a given class name\nexport default classname => {\n  if (!document) return false;\n\n  // get element that has the focus\n  const activeElement = document.activeElement;\n\n  // return false if active element doesn't have ignore-focus class\n  if (!activeElement) return false;\n  if (!activeElement.className) return false;\n  if (activeElement.className.indexOf(classname) === -1) return false;\n\n  return true;\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ToolbarButton = props => {\n\n  // generate class name\n  let className = 'mms--toolbar-button';\n  if (props.disabled) className += ' mms--disabled';\n  if (props.active) className += ' mms--active';\n  if (props.className) className += ` ${props.className}`;\n\n  return (\n    <button\n      id={props.id}\n      className={className}\n      style={props.style}\n      disabled={props.disabled}\n      type={props.type}\n      // use onMouseDown instead of onClick to prevent\n      // the editor from losing focus on button click\n      onMouseDown={e => {\n        e.preventDefault();\n        if (typeof props.onClick === 'function') props.onClick(e);\n        if (typeof props.callback === 'function') props.callback(e);\n      }}\n    >\n      {props.children}\n    </button>\n  )\n};\n\nToolbarButton.propTypes = {\n  id: PropTypes.string,\n  children: PropTypes.any,\n  className: PropTypes.string,\n  style: PropTypes.object,\n  active: PropTypes.bool,\n  disabled: PropTypes.bool,\n  type: PropTypes.string,\n  // for the main function of the button\n  onClick: PropTypes.func,\n  // for side functions of the button\n  callback: PropTypes.func,\n};\n\nexport default ToolbarButton;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ToolbarButton = props => {\n\n  // generate class name\n  let className = 'mms--toolbar-input mms--toolbar-ignore-focus';\n  if (props.disabled) className += ' mms--disabled';\n  if (props.className) className += ` ${props.className || ''}`;\n\n  return (\n    <input\n      id={props.id}\n      className={className}\n      style={props.style}\n      disabled={props.disabled}\n      value={props.value}\n      placeholder={props.placeholder}\n      onChange={e => {\n        e.preventDefault();\n        if (typeof props.onChange === 'function') props.onChange(e);\n        if (typeof props.callback === 'function') props.callback(e);\n      }}\n    >\n      {props.children}\n    </input>\n  )\n};\n\nToolbarButton.propTypes = {\n  id: PropTypes.string,\n  children: PropTypes.any,\n  className: PropTypes.string,\n  style: PropTypes.object,\n  disabled: PropTypes.bool,\n  value: PropTypes.string,\n  placeholder: PropTypes.string,\n  // for the main function of the button\n  onChange: PropTypes.func,\n  // for side functions of the button\n  callback: PropTypes.func,\n};\n\nexport default ToolbarButton;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ItemSpacer = props => (\n  <div\n    className='mms--toolbar-spacer'\n    style={props.style}\n  />\n);\n\nItemSpacer.propTypes = {\n  style: PropTypes.object,\n};\n\nexport default ItemSpacer;\n","/* eslint-disable react/prop-types */\n\nimport React, { useState, useEffect } from 'react';\nimport useEditor from '@editor/hooks/useEditor';\n\n// icons from -\n// https://blueprintjs.com/docs/#icons\nimport { ReactComponent as IconHeadings } from '@assets/heading.svg';\nimport { ReactComponent as IconHeadingOne } from '@assets/heading1.svg';\nimport { ReactComponent as IconHeadingTwo } from '@assets/heading2.svg';\nimport { ReactComponent as IconHeadingThree } from '@assets/heading3.svg';\nimport { ReactComponent as IconBold } from '@assets/bold.svg';\nimport { ReactComponent as IconItalic } from '@assets/italic.svg';\nimport { ReactComponent as IconUnderline } from '@assets/underline.svg';\nimport { ReactComponent as IconStrikethrough } from '@assets/strikethrough.svg';\nimport { ReactComponent as IconTrash } from '@assets/trash.svg';\nimport { ReactComponent as IconShare } from '@assets/share.svg';\nimport { ReactComponent as IconTick } from '@assets/tick.svg';\nimport { ReactComponent as IconLink } from '@assets/link.svg';\nimport { ReactComponent as IconListNumbered } from '@assets/listnum.svg';\nimport { ReactComponent as IconListBulleted } from '@assets/listbul.svg';\nimport { ReactComponent as IconQuote } from '@assets/quote.svg';\n\nimport cleanUrl from '@utils/cleanUrl';\nimport isValidUrl from '@utils/isValidUrl';\nimport classHasFocus from '@utils/classHasFocus';\n\nimport ToolbarButton from '@components/toolbar/ToolbarButton';\nimport ToolbarInput from '@components/toolbar/ToolbarInput';\nimport ItemSpacer from '@components/toolbar/ItemSpacer';\n\nconst SCREEN_DEFAULT = 'default';\nconst SCREEN_HEADINGS = 'headings';\nconst SCREEN_LINK = 'link';\nconst SCREEN_LINK_POPUP = 'link-popup';\n\n// Utils\n\nexport const BackToDefaultScreen = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-back'\n    onClick={() => props.setScreen(SCREEN_DEFAULT)}\n    children={props.children || ''}\n  />\n);\n\n// Headings\n\nexport const HeadingsButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-h'\n    active={props.formats.isHeading}\n    onClick={() => props.setScreen(SCREEN_HEADINGS)}\n    children={props.children || <IconHeadings />}\n  />\n);\n\nexport const HeadingOneButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-h1'\n    active={props.formats.isH1}\n    children={props.children || <IconHeadingOne />}\n    onClick={() => {\n      props.functions.toggleHeading(1);\n      props.setScreen(SCREEN_DEFAULT);\n    }}\n  />\n);\n\nexport const HeadingTwoButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-h2'\n    active={props.formats.isH2}\n    children={props.children || <IconHeadingTwo />}\n    onClick={() => {\n      props.functions.toggleHeading(2);\n      props.setScreen(SCREEN_DEFAULT);\n    }}\n  />\n);\n\nexport const HeadingThreeButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-h3'\n    active={props.formats.isH3}\n    children={props.children || <IconHeadingThree />}\n    onClick={() => {\n      props.functions.toggleHeading(3);\n      props.setScreen(SCREEN_DEFAULT);\n    }}\n  />\n);\n\n// lists\n\nexport const ListNumberedButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-ol'\n    active={props.formats.isListNumbered}\n    onClick={() => props.functions.toggleListNumbered()}\n    children={props.children || <IconListNumbered />}\n  />\n);\n\nexport const ListBulletedButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-ul'\n    active={props.formats.isListBulleted}\n    onClick={() => props.functions.toggleListBulleted()}\n    children={props.children || <IconListBulleted />}\n  />\n);\n\n// misc\n\nexport const BlockquoteButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-blockquote'\n    active={props.formats.isBlockquote}\n    onClick={() => props.functions.toggleBlockquote()}\n    children={props.children || <IconQuote />}\n  />\n);\n\n// marks\n\nexport const BoldButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-bold'\n    active={props.formats.isBold}\n    onClick={() => props.functions.toggleBold()}\n    children={props.children || <IconBold />}\n  />\n);\n\nexport const ItalicButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-italic'\n    active={props.formats.isItalic}\n    onClick={() => props.functions.toggleItalic()}\n    children={props.children || <IconItalic />}\n  />\n);\n\nexport const UnderlineButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-underline'\n    active={props.formats.isUnderline}\n    onClick={() => props.functions.toggleUnderline()}\n    children={props.children || <IconUnderline />}\n  />\n);\n\nexport const StrikeButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-strikethrough'\n    active={props.formats.isStrikethrough}\n    onClick={() => props.functions.toggleStrikethrough()}\n    children={props.children || <IconStrikethrough />}\n  />\n);\n\n// links\n\nexport const LinkButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-addlink'\n    active={props.formats.isLink}\n    onClick={() => props.setScreen(SCREEN_LINK)}\n    children={props.children || <IconLink />}\n  />\n);\n\nexport const RemoveLinkButton = props => (\n  <ToolbarButton\n    id='mms--toolbar-button-removelink'\n    onClick={() => props.functions.removeLink()}\n    children={props.children || <IconTrash />}\n  />\n);\n\nexport const OpenLinkButton = props => {\n  const link = props.functions.getLink() || {};\n  const clean = cleanUrl(link.href, { addHttps: true });\n  const isValid = isValidUrl(clean);\n  return (\n    <ToolbarButton\n      id='mms--toolbar-button-openlink'\n      disabled={!isValid}\n      onClick={() => window.open(clean)}\n      children={props.children || <IconShare />}\n    />\n  )\n};\n\nexport const LinkInput = props => {\n  const [url, setUrl] = useState('');\n\n  const editor = useEditor();\n\n  // if selection is on an existing link, set the\n  // set the input value to the existing link,\n  // so insert link input functions as updater\n  useEffect(() => {\n    const existing = props.functions.getLink() || {};\n    if (existing && existing.href) setUrl(existing.href);\n  }, [editor.selection]);\n\n  const isPopupScreen = props.screen === SCREEN_LINK_POPUP;\n  const classname = isPopupScreen\n    ? 'mms--link-popup-input'\n    : 'mms--link-input';\n\n  const clean = cleanUrl(url);\n  const isValid = isValidUrl(clean);\n\n  const onFormSubmit = e => {\n    e.preventDefault();\n    props.functions.replaceLink(clean);\n    // TODO (BUG2): after replacing a link, because of the\n    // appended classname, it keeps stuck at the link\n    // screen until focusing out of the text input\n    if (!isPopupScreen) props.setScreen(SCREEN_DEFAULT);\n  }\n\n  return (\n    <form\n      style={{ display: 'flex' }}\n      onSubmit={onFormSubmit}\n    >\n      <ToolbarInput\n        value={url}\n        id='mms--toolbar-input-link'\n        onChange={e => setUrl(e.target.value)}\n        placeholder='Insert URL'\n        className={classname}\n      />\n      <ToolbarButton\n        type='submit'\n        id='mms--toolbar-button-submitlink'\n        disabled={!isValid}\n        children={<IconTick />}\n        onClick={onFormSubmit}\n      />\n    </form>\n  )\n}\n\n// misc\n\nexport const isOpen = ({ formats }) => {\n  // if selection on a link and it is collapsed,\n  // force show the toolbar to allow link editing\n  if (formats.isLink && formats.isCollapsed) return true;\n  // return null for default behaviour\n  return null;\n}\n\nexport const forceScreen = ({ formats }) => {\n  // if selection on a link and it is collapsed,\n  // force render the link screen\n  if (formats.isLink && formats.isCollapsed) return SCREEN_LINK_POPUP;\n  // if focused on the link input, keep the relevant screen open\n  if (classHasFocus('mms--link-input')) return SCREEN_LINK;\n  if (classHasFocus('mms--link-popup-input')) return SCREEN_LINK_POPUP;\n  // do not force a screen\n  return null;\n}\n\nexport default {\n\n  toolbar: {\n\n    isOpen,\n\n    forceScreen,\n\n    inline: true,\n\n    defaultScreen: SCREEN_DEFAULT,\n\n    screens: {\n\n      // default screen layout\n      [SCREEN_DEFAULT]: [\n        HeadingsButton,\n        ListNumberedButton,\n        ListBulletedButton,\n        LinkButton,\n        BlockquoteButton,\n        ItemSpacer,\n        BoldButton,\n        ItalicButton,\n        UnderlineButton,\n        StrikeButton,\n      ],\n\n      // headings screen layout\n      [SCREEN_HEADINGS]: [\n        BackToDefaultScreen,\n        HeadingOneButton,\n        HeadingTwoButton,\n        HeadingThreeButton,\n      ],\n\n      // link screen layout\n      [SCREEN_LINK]: [\n        BackToDefaultScreen,\n        LinkInput,\n        RemoveLinkButton,\n        OpenLinkButton,\n      ],\n      [SCREEN_LINK_POPUP]: [\n        LinkInput,\n        RemoveLinkButton,\n        OpenLinkButton,\n      ],\n    }\n  }\n}\n","// if a breaking change to the data format is made, `data-version`\n// field in package.json should be increased, and a migration script should\n// be implemented in `@editor/deserializer/deserializeRaw/migrations`\n\nexport const types = {\n  p: 'paragraph',\n  h1: 'heading-one',\n  h2: 'heading-two',\n  h3: 'heading-three',\n  a: 'link',\n  ul: 'bulleted-list',\n  ol: 'numbered-list',\n  li: 'list-item',\n  q: 'blockquote',\n  b: 'bold',\n  i: 'italic',\n  u: 'underline',\n  s: 'strikethrough',\n};\n\nexport const attrs = {\n  p: () => ({ type: types.p }),\n  h1: () => ({ type: types.h1 }),\n  h2: () => ({ type: types.h2 }),\n  h3: () => ({ type: types.h3 }),\n  a: ({ href } = {}) => ({ type: types.a, href }),\n  ul: () => ({ type: types.ul }),\n  ol: () => ({ type: types.ol }),\n  li: () => ({ type: types.li }),\n  q: () => ({ type: types.q }),\n  b: () => ({ [types.b]: true }),\n  i: () => ({ [types.i]: true }),\n  u: () => ({ [types.u]: true }),\n  s: () => ({ [types.s]: true }),\n};\n","import { Node, Transforms } from 'slate';\nimport { types } from '@config/common';\n\nexport default {\n  normalizerOptions: {\n    normalize: (editor, [ node, path ]) => {\n\n      // paragraphs cannot nest, has to be top level\n      if (node.type === types.p && path.length !== 1) {\n\n        // unwrap parent node. this will trigger a new normalization\n        // thus this will recursively run until paragraph is at top level\n        const parentPath = path.slice(0, -1);\n        Transforms.unwrapNodes(editor, { at: parentPath })\n\n        // change occured\n        return true;\n      }\n\n      // no change occured\n      return false;\n    }\n  }\n}\n","import { Transforms } from 'slate';\nimport { types } from '@config/common';\n\nexport default {\n  normalizerOptions: {\n    normalize: (editor, [ node, path ]) => {\n\n      // top-level nodes cannot be text nodes,\n      // they have to be a block-level node\n      if (path.length === 1 && node.hasOwnProperty('text')) {\n\n        // wrap node within a paragraph\n        Transforms.wrapNodes(editor, { children: [], type: types.p }, { at: path })\n\n        // change occured\n        return true;\n      }\n\n      // no change occured\n      return false;\n    }\n  }\n}\n","import { Transforms, Editor } from 'slate';\nimport { types } from '@config/common';\n\nexport default {\n  onKeyDown: (e, { formats, functions }) => {\n\n    const isBackspace = e.key === 'Backspace';\n    const isEnter = e.key === 'Enter';\n    if (!isBackspace && !isEnter) return;\n\n    // item should be in a list\n    const isListNumbered = formats.isListNumbered;\n    const isListBulleted = formats.isListBulleted;\n    if (!(isListNumbered || isListBulleted)) return;\n\n    // get current list item node\n    const editor = functions._getEditor();\n    const matcher = { match: n => n.type === types.li }\n    const [item] = Editor.nodes(editor, matcher);\n    if (!item) return;\n    const [node, _] = item;\n\n    // pressing enter or backspace on an empty list item\n    // turns the list item block into a paragraph\n    if (Editor.isEmpty(editor, node)) {\n      e.preventDefault();\n      if (isListBulleted) functions.toggleListBulleted();\n      if (isListNumbered) functions.toggleListNumbered();\n    }\n  },\n  normalizerOptions: {\n    normalize: (editor, [ node, path ]) => {\n\n      // list items cannot be top level, turn them into paragraphs\n      if (node.type === types.li && path.length === 1) {\n        Transforms.setNodes(editor, { type: types.p }, { at: path })\n        return true;\n      }\n\n      // list items parents must either be bulleted list (ul)\n      // or numbered list (ol). if neither is the case, unwrap\n      // it from parent until it is. if it ends up being at the\n      // top level (ie. has no list ul or ol in its subtree), the\n      // normalizer above will pick up and turn it into a paragraph\n      if (node.type === types.li && path.length > 1) {\n        const parentPath = path.slice(0, -1);\n        const [parentListNode] = Editor.nodes(editor, {\n          at: parentPath,\n          match: n => (n.type === types.ul || n.type === types.ol)\n        });\n        if (!parentListNode) {\n          Transforms.unwrapNodes(editor, { at: parentPath })\n          return true;\n        }\n      }\n\n      return false;\n    }\n  },\n  hotkeys: [\n    {\n      key: 'mod+shift+7',\n      command: ({ functions }) => functions.toggleListNumbered(),\n    },\n    {\n      key: 'mod+shift+8',\n      command: ({ functions }) => functions.toggleListBulleted(),\n    }\n  ]\n};\n","const transformGdocs = el => {\n\n  // do not parse children of li and a tags\n  if (el.tagName === 'LI' || el.tagName === 'A') {\n    el.innerHTML = el.innerText;\n  }\n\n  // leaf nodes where we need to transform the styles\n  if (el.tagName === 'SPAN' || el.tagName === 'LI') {\n    const tags = [];\n\n    // extract styles\n    if (el.style.fontWeight === '700') tags.push('b');\n    if (el.style.fontStyle === 'italic') tags.push('i');\n    if ((el.style.textDecoration || '').indexOf('underline') !== -1) tags.push('u');\n    if ((el.style.textDecoration || '').indexOf('line-through') !== -1) tags.push('s');\n\n    const container = document.createElement('span');\n    container.innerText = el.innerText;\n\n    // wrap extracted tags and return\n    const wrapped = tags.reduce((acc, tag) => {\n      const newTag = document.createElement(tag);\n      newTag.appendChild(acc.cloneNode(true))\n      return newTag;\n    }, container);\n\n    // el.innerHTML = wrapped.innerHTML;\n    const base = document.createElement(el.tagName);\n    base.appendChild(wrapped.cloneNode(true));\n    return base;\n  }\n\n  const children = el.children || [];\n\n  // base case - no children\n  if (children.length === 0) return el;\n\n  // process children\n  const newChildren = Array\n    .from(children)\n    .map(transformGdocs);\n\n  // create a new element with the same tag\n  let newEl = null;\n  try {\n    newEl = document.createElement(el.tagName);\n  } catch (e) {\n    newEl = document.createElement('span');\n  }\n\n  // add new children\n  newChildren.forEach(c => {\n    newEl.appendChild(c.cloneNode(true))\n  })\n\n  return newEl;\n}\n\nexport default {\n  htmlDeserializerOptions: {\n    transforms: [\n      el => {\n        try {\n\n          // google docs returns markup in a b\n          // tag with `font-weight: normal`\n          if (\n            el.tagName === 'B' &&\n            el.style.fontWeight === 'normal' &&\n            el.id.indexOf('docs-internal-guid') !== -1\n          ) {\n\n            // convert the root b tag into a div, which will\n            // then be eliminated by the deserializer later on\n            const newEl = document.createElement('div');\n            newEl.innerHTML = el.innerHTML;\n\n            // start transformation from the new root\n            return transformGdocs(newEl);\n          }\n\n          return el;\n\n        } catch (e) {\n          return el;\n        }\n      }\n    ],\n  }\n};\n","// Normalize html string and replace some characters\nconst normalizeHtmlString = (str = '') => str\n  // remove unnecessary <o:p>...</o:p> tags\n  .replace(/<o:p>(.|\\n)*?<\\/o:p>/g, '');\n\n// ms office produces html in a way that text\n// are not individually wrapped with DOM nodes\n// and can appear as their siblings. for example:\n// `<p>Click <a href=\"...\">here</a>.</p>`\n// this causes the text nodes to be ignored,\n// therefore text nodes needs to be wrapped with\n// span tags, and these span tags should have no\n// children other than the text they contain\nconst wrapTextNodes = el => {\n  // already a text node\n  if (el.nodeType === 3) return el;\n  // element has no text nodes\n  if (Array.from(el.childNodes).every(c => c.nodeType !== 3)) return el;\n  // every child of this element is already a text node\n  if (Array.from(el.childNodes).every(c => c.nodeType === 3)) return el;\n  // shallow clone node\n  const newEl = el.cloneNode(false);\n  // add child nodes, wrapping text within spans\n  (el.childNodes || []).forEach(child => {\n    if (child && child.nodeType === 3) {\n      // text node\n      const wrapper = document.createElement('span');\n      wrapper.innerText = child.textContent;\n      newEl.appendChild(wrapper);\n    } else {\n      newEl.appendChild(child.cloneNode(true));\n    }\n  })\n\n  return newEl;\n}\n\n// reference to the list container being parsed\nlet activeListRef = null;\n\n// Parse MS word clipboard contents\nconst transformMsOffice = _el => {\n\n  const el = wrapTextNodes(_el);\n\n  // list items\n  if (el.className.indexOf('MsoList') !== -1) {\n\n    // list item class names\n    const isFirst = el.className.indexOf('First') !== -1;\n    const isLast = el.className.indexOf('Last') !== -1;\n\n    // if this is the first list item, create a list wrapper and\n    // keep its ref in the window var for the following recursions\n    if (isFirst) {\n      // TODO: detect list style (ul / ol)\n      activeListRef = document.createElement('ul');\n    }\n\n    // convert to list item and append it\n    // to the active list container\n    if (activeListRef) {\n      const listItem = document.createElement('li');\n      listItem.innerHTML = el.innerText;\n      activeListRef.appendChild(listItem);\n    }\n\n    // clear reference to the active list if last list item\n    if (isLast) activeListRef = null;\n\n    // for the first item, return the list container as the\n    // current element, return null for sibling list items and\n    // append them to the active list container ref instead\n    if (isFirst) return activeListRef;\n    else return null;\n  }\n\n  const children = el.children || [];\n\n  // base case - no children\n  if (children.length === 0) return el;\n\n  // process children\n  const newChildren = Array\n    .from(children)\n    .map(transformMsOffice)\n    .filter(Boolean);\n\n  let newEl = null;\n\n  // create a new element with the same tag\n  // MS office generates invalid html tags so\n  // fall back to a span tag\n  try {\n    newEl = document.createElement(el.tagName);\n  } catch (e) {\n    newEl = document.createElement('span');\n  }\n\n  // add new children\n  newChildren.forEach(c => {\n    newEl.appendChild(c.cloneNode(true))\n  })\n\n  return newEl;\n};\n\nexport default {\n  htmlDeserializerOptions: {\n    transforms: [\n      el => {\n        try {\n\n          // include all microsoft office products\n          const isMsOfficeRootElement = el.tagName === 'HTML' && (\n            (el.getAttribute('xmlns:o') || '').indexOf('schemas-microsoft-com:office') !== -1 ||\n            (el.getAttribute('xmlns:w') || '').indexOf('schemas-microsoft-com:office') !== -1 ||\n            (el.getAttribute('xmlns:m') || '').indexOf('schemas.microsoft.com/office') !== -1\n          );\n\n          // only parse the root element\n          if (!isMsOfficeRootElement) return el;\n\n          // grab body contents of the clipboard\n          const body = el.getElementsByTagName('body')[0];\n          const htmlString = body ? body.innerHTML : el.innerHTML;\n\n          // normalize html string\n          const normalizedHtmlString = normalizeHtmlString(htmlString);\n\n          // convert the root tag into a div, which will\n          // then be eliminated by the deserializer later on\n          const newEl = document.createElement('div');\n          newEl.innerHTML = normalizedHtmlString;\n\n          // start transformation from the new root\n          return transformMsOffice(newEl);\n\n        } catch (e) {\n          console.log('err', e);\n          return el;\n        }\n      }\n    ],\n  }\n};\n","export default {\n  htmlDeserializerOptions: {\n    strategies: [\n      { tag: 'head', strategy: 'skip' },\n      { tag: 'meta', strategy: 'skip' },\n      { tag: 'base', strategy: 'skip' },\n      { tag: 'basefont', strategy: 'skip' },\n      { tag: 'title', strategy: 'skip' },\n      { tag: 'data', strategy: 'skip' },\n      { tag: 'style', strategy: 'skip' },\n      { tag: 'link', strategy: 'skip' },\n      { tag: 'script', strategy: 'skip' },\n      { tag: 'noscript', strategy: 'skip' },\n      { tag: 'applet', strategy: 'skip' },\n      { tag: 'embed', strategy: 'skip' },\n      { tag: 'object', strategy: 'skip' },\n      { tag: 'param', strategy: 'skip' },\n      { tag: 'frame', strategy: 'skip' },\n      { tag: 'iframe', strategy: 'skip' },\n      { tag: 'frameset', strategy: 'skip' },\n      { tag: 'img', strategy: 'skip' },\n      { tag: 'map', strategy: 'skip' },\n      { tag: 'area', strategy: 'skip' },\n      { tag: 'canvas', strategy: 'skip' },\n      { tag: 'figcaption', strategy: 'skip' },\n      { tag: 'figure', strategy: 'skip' },\n      { tag: 'picture', strategy: 'skip' },\n      { tag: 'svg', strategy: 'skip' },\n      { tag: 'audio', strategy: 'skip' },\n      { tag: 'source', strategy: 'skip' },\n      { tag: 'track', strategy: 'skip' },\n      { tag: 'video', strategy: 'skip' },\n    ]\n  }\n};\n","export default {\n  hotkeys: [\n    {\n      key: 'mod+b',\n      when: ({ formats }) => !formats.isCollapsed,\n      command: ({ functions }) => functions.toggleBold(),\n    },\n    {\n      key: 'mod+i',\n      when: ({ formats }) => !formats.isCollapsed,\n      command: ({ functions }) => functions.toggleItalic(),\n    },\n    {\n      key: 'mod+u',\n      when: ({ formats }) => !formats.isCollapsed,\n      command: ({ functions }) => functions.toggleUnderline(),\n    },\n    {\n      key: 'mod+s',\n      when: ({ formats }) => !formats.isCollapsed,\n      command: ({ functions }) => functions.toggleStrikethrough(),\n    }\n  ]\n};\n","export default {\n  onKeyUp: (e, { formats, functions }) => {\n    // going on a new line turns off heading\n    if (e.key === 'Enter') {\n      if (formats.isH1) functions.toggleHeading(1);\n      if (formats.isH2) functions.toggleHeading(2);\n      if (formats.isH3) functions.toggleHeading(3);\n    }\n  },\n  hotkeys: [\n    {\n      key: 'mod+opt+1',\n      command: ({ functions }) => functions.toggleHeading(1),\n    },\n    {\n      key: 'mod+opt+2',\n      command: ({ functions }) => functions.toggleHeading(2),\n    },\n    {\n      key: 'mod+opt+3',\n      command: ({ functions }) => functions.toggleHeading(3),\n    },\n  ]\n};\n","import { ReactEditor } from 'slate-react';\n\nexport default editor => {\n  try {\n    ReactEditor.focus(editor);\n  } catch (e) {\n    // if the editor isn't mounted, ReactEditor freaks out.\n    // no need to make a fuss, just gracefully ignore.\n  }\n}\n","import { ReactEditor } from 'slate-react';\n\nexport default editor => {\n  return ReactEditor.isFocused(editor);\n}\n","import { Editor } from 'slate';\n\nexport default (editor, { edge = 'end' } = {}) => {\n\n  // generator for all available points that cursor\n  // could be placed in the document, in reverse order\n  const positionsGen = Editor.positions(editor, {\n    at: [],\n    reverse: edge === 'end', // reverse order for end\n  });\n\n  try {\n    // yield and get the first item\n    return positionsGen.next().value || null;\n  } catch (e) {\n    // it will fail to yield when editor children\n    // is [] and there is nowhere to place the cursor\n    // in which case, return null\n    return null;\n  }\n}\n","import { Transforms } from 'slate';\nimport getDocumentEdgePoint from '@editor/contents/getDocumentEdgePoint';\n\nexport default editor => {\n  Transforms.select(editor, getDocumentEdgePoint(editor, { edge: 'start' }))\n}\n","import { Transforms } from 'slate';\nimport getDocumentEdgePoint from '@editor/contents/getDocumentEdgePoint';\n\nexport default editor => {\n  Transforms.select(editor, getDocumentEdgePoint(editor));\n}\n","import { Editor } from \"slate\";\nimport { types } from \"@config/common\";\n\nexport default editor => {\n  try {\n    // find link nodes within selection\n    const [link] = Editor.nodes(editor, {\n      match: n => n.type === types.a\n    });\n\n    // if no links within selection, (or no selection), return null\n    if (!link || !Array.isArray(link) || !link[0]) return null;\n\n    // return link data\n    return link[0];\n  } catch (error) {\n    console.error(error);\n  }\n};\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","import { Editor } from 'slate';\nimport { types } from '@config/common';\n\nexport default editor => {\n  const [link] = Editor.nodes(editor, {\n    match: n => n.type === types.a\n  });\n\n  return !!link\n}\n","import { Transforms } from 'slate';\nimport { types } from '@config/common';\n\nexport default editor => {\n  Transforms.unwrapNodes(editor, {\n    match: n => n.type === types.a\n  })\n}\n","import { Range, Transforms } from 'slate';\nimport { attrs } from '@config/common';\nimport removeLink from '@editor/links/removeLink';\nimport isLinkActive from '@editor/links/isLinkActive';\n\nexport default (editor, href) => {\n  if (!editor || !editor.selection) return;\n\n  // if there is an active link within selection,\n  // remove the link first\n  if (isLinkActive(editor)) removeLink(editor);\n\n  const { selection } = editor;\n  const isCollapsed = selection && Range.isCollapsed(selection);\n\n  const linkConfig = attrs.a({ href });\n  const link = Object.assign(linkConfig, {\n    children: isCollapsed ? [{ text: href }] : []\n  });\n\n  try {\n    if (isCollapsed) {\n      Transforms.insertNodes(editor, link);\n    } else {\n      Transforms.wrapNodes(editor, link, { split: true });\n      Transforms.collapse(editor, { edge: \"end\" });\n    }\n  } catch (error) {\n    console.error(error);\n  }\n};\n","import { Transforms } from 'slate';\nimport get from 'lodash/get';\nimport { types, attrs } from '@config/common';\nimport isLinkActive from '@editor/links/isLinkActive';\nimport insertLink from '@editor/links/insertLink';\nimport getLink from '@editor/links/getLink';\n\nexport default (editor, href) => {\n\n  // if no link exists, insert link\n  if (!isLinkActive(editor)) insertLink(editor, href);\n\n  // get current link\n  const currentLink = getLink(editor);\n  const currentLinkText = get(currentLink, 'children[0].text');\n  const currentLinkHref = get(currentLink, 'href');\n\n  // if current links anchor text is the same as its current\n  // href, we should also replace the anchor text with the new href\n  const newLinkText = (currentLinkText === currentLinkHref) ? href : currentLinkText;\n\n  // update current nodes link\n  Transforms.setNodes(editor, attrs.a({ href }), {\n    match: n => n.type === types.a\n  });\n\n  // update anchor text\n  const updatePath = get(editor, 'selection.anchor.path') || get(editor, 'selection.focus.path');\n  if (updatePath) Transforms.insertText(editor, newLinkText, { at: updatePath });\n}\n","import { Transforms } from 'slate';\nimport getDocumentEdgePoint from '@editor/contents/getDocumentEdgePoint';\n\nexport default editor => {\n\n  // get start and end\n  const startPoint = getDocumentEdgePoint(editor, { edge: 'start' });\n  const endPoint = getDocumentEdgePoint(editor);\n\n  // select\n  Transforms.select(editor, {\n    anchor: startPoint,\n    focus: endPoint,\n  })\n}\n","/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n","import { types } from '@config/common';\n\nexport const initialRange = {\n  anchor: { path: [0, 0], offset: 0 },\n  focus: { path: [0, 0], offset: 0 },\n};\n\nexport default [{\n  type: types.p,\n  children: [{ text: '' }]\n}];\n","import isNil from 'lodash/isNil';\nimport initialValue, { initialRange } from '@config/initialValue';\n\nexport default (editor, setValue) => {\n\n  // set editor children and selection\n  editor.children = initialValue;\n  if (!isNil(editor.selection)) {\n    editor.selection = initialRange;\n  }\n\n  // set editor state.\n  setValue(initialValue);\n}\n","import { Node } from 'slate';\n\nexport default editor => {\n  return Node.string(editor) === '';\n}\n","import { Node } from 'slate';\n\nexport default editor => {\n  if (!editor || !editor.children || !Array.isArray(editor.children)) {\n    return null;\n  }\n\n  return editor.children.map(n => Node.string(n)).join('\\n')\n}\n","import { Editor } from 'slate';\n\nexport default (editor, type, format) => {\n  try {\n\n    if (type === 'mark') {\n\n      // mark type\n      const marks = Editor.marks(editor);\n      return marks ? marks[format] === true : false;\n\n    } else {\n\n      // block type\n      const [match] = Editor.nodes(editor, {\n        match: n => n.type && n.type === format,\n      })\n\n      return !!match;\n    }\n  } catch (e) {\n\n    // when failing to find nodes\n    // the format is not active\n    return false;\n  }\n}\n","import { Transforms } from 'slate';\n\n/**\n * This fixes the issue where double clicking on a block extends the selection to\n * the beginning of the next block; and Transformations that includes wrapping, such\n * as making a block a list item, effects the next block.\n * ---\n * When a selection starts from the a block and extends until the offset 0 of the next\n * block, move selection up to the end of the block.\n *\n * Input:\n * {\n *   anchor: { offset: x, path: [ n, _, _, ... ] },\n *   focus: { offset: 0, path: [ n + 1, _, _, ... ] }\n * }\n* Output:\n * {\n *   anchor: { offset: x, path: [ n, _, _, ... ] },\n *   focus: { offset: <block_end>, path: [ n, _, _, ... ] }\n * }\n */\n\nexport default editor => {\n  if (!editor.selection) return;\n\n  const anchor = editor.selection.anchor;\n  const focus = editor.selection.focus;\n\n  if (!anchor || !anchor.path) return;\n  if (!focus || !focus.path) return;\n\n  const extendsToNextBlock = anchor.path[0] + 1 === focus.path[0];\n  const focusAtOffsetZero = focus.offset === 0;\n\n  if (extendsToNextBlock && focusAtOffsetZero) {\n    Transforms.move(editor, {\n      distance: 1,\n      unit: 'offset',\n      reverse: true,\n    })\n  }\n}\n","import { Editor, Transforms, Text } from 'slate';\nimport isNil from 'lodash/isNil';\nimport { types } from '@config/common';\nimport isFormatActive from '@editor/formatters/isFormatActive';\nimport normalizeSelection from '@editor/selection/normalizeSelection';\n\nexport default (editor, type, format, { status } = {}) => {\n  Editor.withoutNormalizing(editor, () => {\n\n    // fix selection anormalities\n    normalizeSelection(editor);\n\n    // toggle to opposite state\n    const isActive = isFormatActive(editor, type, format)\n    let toggleOn = !isActive;\n\n    // if status specified, toggle to that\n    if (!isNil(status)) toggleOn = status;\n\n    // mark type. split if text\n    if (type === 'mark') {\n      Transforms.setNodes(\n        editor,\n        { [format]: toggleOn || null },\n        { match: Text.isText, split: true }\n      );\n    } else {\n      // block type\n\n      // are we toggling a list type ?\n      const listTypeTypes = [types.ol, types.ul];\n      const isListType = listTypeTypes.includes(format);\n\n      // if toggling list node, unwrap it first\n      Transforms.unwrapNodes(editor, {\n        match: n => listTypeTypes.includes(n.type),\n        split: true,\n      })\n\n      // if toggling off, set block to the default block type (ie. paragraph)\n      // otherwise, set to the desired format it is a non-list format. if it is\n      // a list format, set block to list-item format (and wrap it around the list\n      // format later on)\n      Transforms.setNodes(editor, {\n        type: !toggleOn\n          ? types.p\n          : (isListType ? types.li : format)\n      })\n\n      // if toggling on a list type, wrap the list\n      // item children around parent list format\n      if (toggleOn && isListType) {\n        Transforms.wrapNodes(editor, {\n          type: format,\n          children: []\n        })\n      }\n    }\n  });\n}\n","import packageJson from '@/package.symlink.json';\n\nexport default {\n  version: packageJson['version'],\n  data_version: packageJson['data-version'],\n  slate_version: packageJson['dependencies']['slate'],\n  slate_history_version: packageJson['dependencies']['slate-history'],\n  slate_react_version: packageJson['dependencies']['slate-react'],\n};\n","import versions from '@config/versions';\n\nexport default (data, metadata = {}) => ({\n  ...metadata,\n  ...versions,\n  data,\n});\n","import serializeRaw from '@editor/serializer/serializeRaw/serializeRaw';\n\nexport default (editor, { history } = {}) => {\n  if (!editor || !editor.children) return null;\n  const value = editor.children;\n  const metadata = history ? { history: editor.history } : {};\n  return serializeRaw(value, metadata);\n};\n","import { types } from '@config/common';\n\nconst serializeHtml = (node = {}) => {\n\n  // base case: leaf\n  if (node.hasOwnProperty('text')) {\n    let out = node.text;\n\n    if (node[types.s]) out = `<s>${out}</s>`;\n    if (node[types.u]) out = `<u>${out}</u>`;\n    if (node[types.i]) out = `<i>${out}</i>`;\n    if (node[types.b]) out = `<b>${out}</b>`;\n\n    return out;\n  }\n\n  // this is not a text node, and has no children\n  // silently handle the case by returning empty string\n  if (!node.children) {\n    return '';\n  }\n\n  // paragraph\n  if (node.type === types.p) {\n    return `<p>${serializeHtmlNodes(node.children)}</p>`;\n  }\n\n  // headings\n  if (node.type === types.h1) return `<h1>${serializeHtmlNodes(node.children)}</h1>`;\n  if (node.type === types.h2) return `<h2>${serializeHtmlNodes(node.children)}</h2>`;\n  if (node.type === types.h3) return `<h3>${serializeHtmlNodes(node.children)}</h3>`;\n\n  // link\n  if (node.type === types.a) {\n    return `<a href=\"${node.href}\">${serializeHtmlNodes(node.children)}</a>`;\n  }\n\n  // blockquote\n  if (node.type === types.q) {\n    return `<blockquote>${serializeHtmlNodes(node.children)}</blockquote>`;\n  }\n\n  // lists\n  if (node.type === types.ul) return `<ul>\\n${serializeHtmlNodes(node.children, '\\n')}\\n</ul>`;\n  if (node.type === types.ol) return `<ol>\\n${serializeHtmlNodes(node.children, '\\n')}\\n</ol>`;\n  if (node.type === types.li) return `<li>${serializeHtmlNodes(node.children)}</li>`;\n\n  // base case: invalid input\n  // return empty string\n  return '';\n};\n\nconst serializeHtmlNodes = (nodes, delim = '') => {\n  const useNodes = Array.isArray(nodes) ? nodes : [nodes];\n  return useNodes.filter(Boolean).map(serializeHtml).join(delim);\n}\n\nexport default data => {\n  return serializeHtmlNodes(data, '\\n');\n};\n","import serializeHtml from '@editor/serializer/serializeHtml/serializeHtml';\n\nexport default editor => {\n  if (!editor || !editor.children) return null;\n  return serializeHtml(editor.children);\n};\n","// a function to walk down the node tree and\n// apply transformations on each node\nconst walk = (node, transform) => {\n\n  // return null if invalid\n  if (!node || typeof node !== 'object') return null;\n  if (typeof transform !== 'function') return null;\n\n  let newNode = { ...node };\n\n  // transform node\n  newNode = transform(newNode);\n\n  // transform children if any\n  if (newNode.children && Array.isArray(newNode.children)) {\n    newNode.children = newNode.children.map(child => walk(child, transform))\n  }\n\n  return newNode;\n}\n\nexport default (node, transform) => {\n  if (Array.isArray(node)) return node.map(n => walk(n, transform));\n  return walk(node, transform);\n};\n","// add migration scripts like below\n// <from_version>: { to: <to_version>, fn: <migration_function> }\nimport v0v1 from '@editor/deserializer/deserializeRaw/migrations/v0v1';\n\nexport const migrations = {\n  0: { to: 1, fn: v0v1 },\n};\n\nexport default (migration, raw) => {\n  const migrated = migration.fn(raw.data);\n  return {\n    ...raw,\n    data: migrated,\n    data_version: migration.to,\n  }\n};\n","// this is to serve as an example migration script for a hypothetical\n// data format change from version zero to one\n\n// 1 ---\n// change: mark level type `boldAndItalic` removed\n// interpretation: marks `bold` and `italic` should be applied\n\n// 2 ---\n// change: block level type `double-paragraph` removed\n// interpretation: type `paragraph` block should be used instead\n\n// 3 ---\n// change: block level type `hyperlink` renamed to `link`\n// change: its attribute `src` renamed `href`\n\nimport { types } from '@config/common';\nimport walk from '@editor/deserializer/deserializeRaw/utils/walk'\n\nexport default editorData => {\n\n  // walk on every node on the editor data and\n  // run the transformation function\n  return walk(editorData, node => {\n\n    // if node has mark boldAndItalic, remove it and apply bold and italic separately\n    if (node.boldAndItalic) {\n      delete node.boldAndItalic;\n      node[types.b] = true;\n      node[types.i] = true;\n    }\n\n    // if node is of type `double-paragraph`, change its type to `paragraph`\n    if (node.type === 'double-paragraph') {\n      node.type = types.p;\n    }\n\n    // if node is of type `hyperlink`, correct the type and attribute\n    if (node.type === 'hyperlink') {\n      node.type = types.a;\n      node.href = node.src;\n      delete node.src;\n    }\n\n    return node;\n  })\n};\n","import isNil from 'lodash/isNil';\nimport migrate, { migrations } from '@editor/deserializer/deserializeRaw/migrations';\n\nconst deserializeRaw = raw => {\n\n  // invalid data\n  if (!raw || typeof raw !== 'object') return null;\n  if (isNil(raw.version) || isNil(raw.data_version)) return null;\n\n  // if migration available, migrate and rerun function\n  const migration = migrations[raw.data_version];\n  if (migration) return deserializeRaw(migrate(migration, raw));\n\n  // return editor data\n  return raw.data;\n};\n\nexport default deserializeRaw;\n","import isNil from 'lodash/isNil';\nimport deserializeRaw from '@editor/deserializer/deserializeRaw/deserializeRaw';\n\nexport default (editor, setValue, raw) => {\n\n  // throw error for invalid data\n  if (!raw || typeof raw !== 'object') {\n    throw new Error('Failed to import: invalid data');\n  }\n\n  // deserialize\n  const deserialized = deserializeRaw(raw);\n\n  // throw error for failed deserialization\n  if (isNil(deserialized)) {\n    throw new Error('Failed to import: cannot deserialize');\n  }\n\n  // set editor state\n  setValue(deserialized);\n\n  // attach history if present\n  if (raw.history) editor.history = raw.history;\n}\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var isArrayLike = require('./isArrayLike'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n","/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","var assignMergeValue = require('./_assignMergeValue'),\n    cloneBuffer = require('./_cloneBuffer'),\n    cloneTypedArray = require('./_cloneTypedArray'),\n    copyArray = require('./_copyArray'),\n    initCloneObject = require('./_initCloneObject'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLikeObject = require('./isArrayLikeObject'),\n    isBuffer = require('./isBuffer'),\n    isFunction = require('./isFunction'),\n    isObject = require('./isObject'),\n    isPlainObject = require('./isPlainObject'),\n    isTypedArray = require('./isTypedArray'),\n    safeGet = require('./_safeGet'),\n    toPlainObject = require('./toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n","var Stack = require('./_Stack'),\n    assignMergeValue = require('./_assignMergeValue'),\n    baseFor = require('./_baseFor'),\n    baseMergeDeep = require('./_baseMergeDeep'),\n    isObject = require('./isObject'),\n    keysIn = require('./keysIn'),\n    safeGet = require('./_safeGet');\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n","export default (html = '') => html\n  // remove coments\n  .replace(/<!--\\[if(.|\\n)*?endif]-->/g, '')\n  // replace line breaks with spaces\n  // when sentences are broken by a new line, it causes\n  // the space between words to disappear\n  .replace(/(?:\\n\\r|\\r\\n|\\r|\\n)/gm, ' ')\n  // remove spaces and tabs before tags\n  .replace(/^[\\t ]+</g, '<')\n  .replace(/[\\t ]+</g, ' <')\n  // remove multiple spaces and tabs between tags\n  .replace(/>[\\t ]+</g, '> <')\n  // remove whitespace after tags\n  .replace(/>[\\t ]+$/g, '>')\n  .replace(/>[\\t ]+/g, '> ')\n  // replace more than two space characters\n  // with a single space\n  .replace(/\\s\\s+/g, ' ')\n  // replace space character variations\n  .replace(/\\u21B5|\\u2000|\\u2001|\\u2002|\\u2003|\\u2004|\\u2005|\\u2006|\\u2007|\\u2008|\\u2009|\\u00A0/g, ' ')\n  // replace dash character variations\n  .replace(/\\u2010|\\u2011|\\u2012|\\u2013|\\u2014|\\u2015/g, '-')\n  // replace vertical bar character variations\n  .replace(/\\u2016/g, '|')\n  // replace opening - closing single quotes with standard\n  .replace(/|/g, `'`)\n  // replace opening - closing double quotes with standard\n  .replace(/|/g, `\"`)\n  // replace three dots character with three dots\n  .replace(//g, `...`);\n","// convert tag settings into dictionary grouped by tags\nexport default (strategies = []) => {\n  if (!Array.isArray(strategies)) return {};\n  return strategies.reduce((acc, strategy) => {\n    const t = (strategy.tag || '').toLowerCase();\n    return { ...acc, [t]: strategy.strategy };\n  }, {});\n};\n","// extract attributes from NamedNodeMap to plain object\nexport default el => {\n  if (!el || !el.attributes) return {};\n  const res = {};\n  const args = el.attributes;\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    res[arg.nodeName] = arg.nodeValue;\n  }\n  return res;\n};\n","export default (list = [], key) => {\n  return list\n    .filter(i => i && typeof i === 'object')\n    .map(i => i[key])\n    .filter(i => !!i)\n    .reduce((acc, l) => acc.concat(l), [])\n};\n","import mapReduceFlatten from '@utils/mapReduceFlatten';\n\n// combine a list of htmlDeserializerOption objects\nexport default (htmlDeserializerOptionsList = []) => {\n  const transforms = mapReduceFlatten(htmlDeserializerOptionsList, 'transforms');\n  const strategies = mapReduceFlatten(htmlDeserializerOptionsList, 'strategies');\n\n  return {\n    transforms,\n    strategies,\n  }\n};\n","/**\n * This is a normalizer that's meant to be run only after\n * deserialization, it is destructive and should not be run\n * as the regular normalizer as it'll change the contents of\n * the document\n */\n\nimport { Node } from 'slate';\nimport { types } from '@config/common';\n\nexport default (fragments = []) => fragments\n\n  // wrap lonely text nodes\n  .map(f => (\n    (!f.type && f.text)\n      ? { children: [f], type: types.p }\n      : f\n  ))\n\n  // filter out empty paragraph nodes\n  .filter(node => {\n    if (node.type === types.p) {\n      return Node.string(node).trim() !== ''\n    }\n\n    return true;\n  })\n","export default props => {\n\n  // strip props added by babel\n  if (props && props.hasOwnProperty('__self')) delete props.__self;\n  if (props && props.hasOwnProperty('__source')) delete props.__source;\n\n  return props;\n};\n","import { attrs } from '@config/common';\nimport removeBabelProps from '@utils/removeBabelProps';\n\n// deserializer instructions --\n\n// _instructions (instructions object) -\n// pass these instructions down to further children\n// _instructionsTag (instructions object) -\n// applies only to the current tag, do not pass on\n\n// pass these args to all children\nexport const CHILDREN_ARGS = 'children-args';\n// pass these args to all leafs (ie. text nodes)\nexport const CHILDREN_LEAF_ARGS = 'children-leaf-args';\n// pass these args to all non-leaf nodes (ie. element nodes)\nexport const CHILDREN_NODE_ARGS = 'children-node-args';\n// this tag is for styling (ie. <b>...</b>). do not\n// wrap, ignore and move on to the children\nexport const STYLE_TAG = 'style-tag';\n\nconst leaf = (args = {}, custom = {}) => ({\n  ...args,\n  ...custom,\n  _instructions: { [CHILDREN_LEAF_ARGS]: custom },\n  _instructionsTag: { [STYLE_TAG]: true },\n})\n\n// leafs\nconst bold = (args = {}) => leaf(args, attrs.b());\nconst italic = (args = {}) => leaf(args, attrs.i());\nconst underline = (args = {}) => leaf(args, attrs.u());\nconst strikethrough = (args = {}) => leaf(args, attrs.s());\n\n// elements\nconst paragraph = (_, children) => ({ children, ...attrs.p() })\nconst headingOne = (_, children) => ({ children, ...attrs.h1() })\nconst headingTwo = (_, children) => ({ children, ...attrs.h2() })\nconst headingThree = (_, children) => ({ children, ...attrs.h3() });\nconst link = ({ href } = {}, children) => ({ children, ...attrs.a({ href }) });\nconst listBulleted = (_, children) => ({ children, ...attrs.ul() });\nconst listNumbered = (_, children) => ({ children, ...attrs.ol() });\nconst listItem = (_, children) => ({ children, ...attrs.li() });\nconst blockQuote = (_, children) => ({ children, ...attrs.q() });\n\n// misc\nconst fragment = (args = {}, children) =>\n  ({ ...args, children: Array.isArray(children) ? children : [children] });\nconst text = (args = {}, text) =>\n  ({ ...args, text: String(text) });\n\n// map allowed tags to functions\nexport const tags = {\n  '#TEXT': text,\n  'FRAGMENT': fragment,\n  'BLOCK': fragment,\n  'BR': paragraph, // <- treat br tags as empty paragraphs\n  'P': paragraph,\n  'BLOCKQUOTE': blockQuote,\n  'Q': blockQuote,\n  'H1': headingOne,\n  'H2': headingTwo,\n  'H3': headingThree,\n  'H4': headingThree,\n  'H5': headingThree,\n  'H6': headingThree,\n  'A': link,\n  'UL': listBulleted,\n  'OL': listNumbered,\n  'LI': listItem,\n  'B': bold,\n  'STRONG': bold,\n  'I': italic,\n  'EM': italic,\n  'U': underline,\n  'S': strikethrough,\n  'DEL': strikethrough,\n  'STRIKE': strikethrough,\n};\n\nexport const isKnown = tag => {\n  const useTag = tag.toUpperCase();\n  return typeof tags[useTag] === 'function';\n}\n\nexport default (\n  tag = '',\n  attrs = {},\n  children,\n  options = {},\n) => {\n\n  // strip attrs added by babel\n  removeBabelProps(attrs);\n\n  if (!isKnown(tag)) return children;\n\n  const useTag = tag.toUpperCase();\n  const fn = tags[useTag];\n\n  if (!fn) return children;\n\n  // deserialize node\n  const res = fn(attrs, children);\n\n  // if children is string, it's a text node\n  if (typeof res.children === 'string') {\n    res.children = [text({}, res.children)]\n  }\n\n  // strings in children array are also text nodes\n  if (Array.isArray(res.children)) {\n    res.children = res.children.map(c => {\n      if (c && typeof c === 'string') return text({}, c);\n      return c;\n    })\n  }\n\n  // this function deserializes a single node. however in\n  // some cases, additional data / attributes needs to be\n  // passed on to the children based on the node. for\n  // those cases, pass `pre: true` to. if pre-deserializing\n  // instructions to the parser will be passed on how to parse\n  // current nodes children\n  const { pre } = options;\n\n  // only pass `pre` data\n  if (!pre) delete res._instructions;\n\n  return res;\n};\n","import merge from 'lodash/merge';\nimport cleanHtml from '@utils/cleanHtml';\nimport strategiesToDict from '@editor/deserializer/deserializeHtml/utils/strategiesToDict';\nimport extractAttributes from '@editor/deserializer/deserializeHtml/utils/extractAttributes';\nimport combineOptions from '@editor/deserializer/deserializeHtml/utils/combineOptions';\nimport postDeserializeNormalization from '@editor/deserializer/deserialize/postDeserializeNormalization';\n\nimport deserialize, {\n  STYLE_TAG,\n  CHILDREN_ARGS,\n  CHILDREN_LEAF_ARGS,\n  CHILDREN_NODE_ARGS,\n} from '@editor/deserializer/deserialize';\n\n// strategy constants\nexport const TEXT = 'text';\nexport const TEXT_CHILDREN = 'textChildren';\nexport const CONTINUE = 'continue';\nexport const CONTINUE_TEXT = 'continueText';\nexport const SKIP = 'skip';\n\nconst deserializeHtml = (options = {}, el, inherit = {}) => {\n\n  const {\n\n    // adjust render behaviour\n    // key (string): tag names\n    // value (string or function( el: HTMLElement, attrs: object ) -> string) - parse\n    // configuration, or fn that receives el and attributes, and returns configuration\n    // possible values: normal (default), text, textChildren, continue, continueText and skip\n    strategiesDict = {},\n\n    // transform HTMLElement\n    transforms,\n\n  } = options;\n\n  let current = el;\n  let htmlAttrs = extractAttributes(el);\n\n  // if a transform function provided, re-set\n  // current to the HTMLElement returned from it\n  if (Array.isArray(transforms)) {\n    transforms.forEach(transform => {\n      if (typeof transform === 'function') {\n        current = transform(current);\n      }\n    })\n  }\n\n  // if invalid node returned from transform function, return\n  if (!current) return [];\n\n  let { nodeType, nodeName, textContent } = current;\n\n  // extract tag settings\n  let strategy = strategiesDict[nodeName.toLowerCase()];\n\n  // if strategy is a function\n  // execute it to get the settings\n  if (typeof strategy === 'function') {\n    strategy = strategy(current, htmlAttrs);\n  }\n\n  // get deserialize strategy for this tag\n  let strategySkip = strategy === SKIP;\n  let strategyContinue = strategy === CONTINUE;\n  let strategyContinueText = strategy === CONTINUE_TEXT;\n  let strategyText = strategy === TEXT;\n  let strategyTextChildren = strategy === TEXT_CHILDREN;\n\n  // parser instructions ---\n\n  // html deserializer runs from leafs to root.\n  // pre-deserialize current node to see if its\n  // children should inherit any properties\n  const _inherited = inherit._instructions || {};\n  const pre = deserialize(nodeName, htmlAttrs, [], { pre: true });\n  const _instructionsForChildren = merge({}, _inherited, pre._instructions);\n  const _instructionsForCurrentNode = merge({}, _instructionsForChildren, pre._instructionsTag);\n  const isStyleTag = _instructionsForCurrentNode[STYLE_TAG];\n  const childrenArgs = _instructionsForCurrentNode[CHILDREN_ARGS] || {};\n  const childrenLeafArgs = _instructionsForCurrentNode[CHILDREN_LEAF_ARGS];\n  const childrenNodeArgs = _instructionsForCurrentNode[CHILDREN_NODE_ARGS];\n\n  // get data on current node\n  const isText = nodeType === window.Node.TEXT_NODE;\n  const isElement = nodeType === window.Node.ELEMENT_NODE;\n  const isLink = nodeName === 'A';\n  const hasTextContent = !!textContent;\n\n  // enhance current nodes args\n  let instructionArgs = { ...childrenArgs }\n  if (isText) instructionArgs = { ...instructionArgs, ...childrenLeafArgs }\n  if (isElement) instructionArgs = { ...instructionArgs, ...childrenNodeArgs }\n\n  // forced settings ---\n\n  // do not parse style tags as individual tags\n  if (isStyleTag) strategyContinue = true;\n  // only evaluate element nodes (ie. <p>, <div> etc.)\n  if (!isElement && !isText) strategyContinue = true;\n  // if an element has nothing in it to render, ignore\n  if (!hasTextContent) strategySkip = true;\n  // if text node, its content is its children\n  if (isText) strategyText = true;\n  // if a link has no href, treat it as a text node\n  if (isLink && !htmlAttrs.href) strategyText = true;\n\n  // deserialize --\n\n  // skip node and all its children\n  if (strategySkip) {\n    return [];\n  }\n\n  // skip current node and continue with children as text\n  if (strategyContinueText) {\n    return deserialize('#text', { ...instructionArgs }, Array.from(current.children)\n      .map(child => child.textContent)\n      .join(' '));\n  }\n\n  // parse node and all its children as text node\n  if (strategyText) {\n    return deserialize('#text', { ...instructionArgs }, textContent);\n  }\n\n  // parse node normally and its children as text\n  if (strategyTextChildren) {\n    return deserialize(nodeName, { ...htmlAttrs, ...instructionArgs }, textContent);\n  }\n\n  // deserialize children\n  let children = Array.from(current.childNodes)\n    .map(child => deserializeHtml(options, child, { _instructions: _instructionsForChildren }))\n    .flat()\n\n  // skip current node and continue with children\n  if (strategyContinue) {\n    return children;\n  }\n\n  // parse node and children normally\n  return deserialize(nodeName, { ...htmlAttrs, ...instructionArgs }, children);\n}\n\nexport default (htmlDeserializerOptionsList = []) => (...strs) => {\n\n  // cover tag function usage (ie. invocation with template literals)\n  const html = Array.isArray(strs[0]) ? String.raw(...strs) : strs[0];\n  const clean = cleanHtml(html);\n  const parsed = new window.DOMParser().parseFromString(clean, 'text/html');\n  const rootEl = parsed.documentElement;\n\n  const {\n    transforms,\n    strategies,\n  } = combineOptions(\n    htmlDeserializerOptionsList);\n\n  return postDeserializeNormalization(\n    deserializeHtml({\n      transforms,\n      strategiesDict: strategiesToDict(strategies)\n    }, rootEl, {})\n  );\n};\n","import { Node, Editor, Transforms } from 'slate';\nimport isNil from 'lodash/isNil';\nimport hasFocus from '@editor/focus/hasFocus';\nimport deserializeHtml from '@editor/deserializer/deserializeHtml/deserializeHtml';\n\nconst normalize = editor => {\n  // execute on the next event loop tick\n  setTimeout(() => {\n    Editor.normalize(editor, { force: true })\n  })\n};\n\nexport default (editor, html, htmlDeserializerOptions) => {\n  const fragment = deserializeHtml(\n    Array.isArray(htmlDeserializerOptions)\n      ? htmlDeserializerOptions\n      : [htmlDeserializerOptions]\n  )(html);\n\n  if (isNil(fragment)) {\n    throw new Error('Failed to insert: cannot deserialize');\n  }\n\n  let at = null;\n  if (editor.selection) {\n    at = editor.selection\n  } else if (editor.children.length > 0) {\n    at = Editor.end(editor, [])\n  } else {\n    at = [0]\n  }\n\n  Transforms.insertNodes(editor, fragment);\n\n  if (at && (!at.offset || at.offset === 0)) {\n    Transforms.delete(editor, { at })\n  }\n\n  normalize(editor);\n};\n","import deserialize from '@editor/deserializer/deserialize';\n\nexport default (text = '') => {\n  const useText = typeof text === 'string' ? text : '';\n  // interpret new lines as paragraphs\n  // remove empty lines\n  return useText\n    .split(/\\n/gi)\n    .filter(t => !!t && t.length > 0)\n    .map(t => (\n      deserialize('P', {}, [\n        deserialize('#TEXT', {}, t)\n      ])\n    ))\n};\n","import { Editor, Node, Transforms } from 'slate';\nimport hasFocus from '@editor/focus/hasFocus';\nimport deserializeText from '@editor/deserializer/deserializeText/deserializeText';\n\nconst normalize = editor => {\n  // execute on the next event loop tick\n  setTimeout(() => {\n    Editor.normalize(editor, { force: true })\n  })\n};\n\nexport default (editor, text) => {\n  const fragment = deserializeText(text);\n\n  let at = null;\n  if (editor.selection) {\n    at = editor.selection\n  } else if (editor.children.length > 0) {\n    at = Editor.end(editor, [])\n  } else {\n    at = [0]\n  }\n  \n  Transforms.insertNodes(editor, fragment);\n  \n  Transforms.delete(editor, { at })\n\n  normalize(editor);\n};\n","import { types } from '@config/common';\nimport toggleFormat from '@editor/formatters/toggleFormat';\n\nexport default (editor, level, status) => {\n  let useType = null;\n  if (level === 1) useType = types.h1;\n  if (level === 2) useType = types.h2;\n  if (level === 3) useType = types.h3;\n\n  if (useType) {\n    toggleFormat(editor, 'block', useType, { status });\n  }\n}\n","import * as s from 'slate';\nimport * as sr from 'slate-react';\n\nexport default editor => {\n  window.slate = s;\n  window.slateReact = sr;\n  window.editor = editor;\n}\n","import { Range } from 'slate';\n\nexport default editor => {\n  // if editor is falsy or has no selection, return null\n  if (!editor) return null;\n\n  // if editor has no selection, return null\n  if (!editor.selection) return null;\n\n  // return collapsed state\n  return Range.isCollapsed(editor.selection);\n}\n","import { createContext, useContext } from 'react';\n\n// create a context for function api's args\nexport const FormatsApiContext = createContext(null);\n\nexport default () => {\n  const formatsApi = useContext(FormatsApiContext);\n\n  if (!formatsApi) {\n    throw new Error('useFormats can only be use inside <MMSEditor> components context.')\n  }\n\n  return formatsApi;\n};\n","import { createContext, useContext } from 'react';\n\n// create a context for function api's args\nexport const FunctionsApiContext = createContext(null);\n\nexport default () => {\n  const functionsApi = useContext(FunctionsApiContext);\n\n  if (!functionsApi) {\n    throw new Error('useFunctions can only be use inside <MMSEditor> components context.')\n  }\n\n  return functionsApi;\n};\n","import { createContext, useContext } from 'react';\n\n// create a context for function api's args\nexport const DecoratorContext = createContext(null);\n\nexport default () => useContext(DecoratorContext);\n","import isPlainObject from 'is-plain-object';\nimport { Operation, Editor, Path } from 'slate';\n\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));\n  }\n\n};\n\n/**\r\n * Weakmaps for attaching state to the editor.\r\n */\n\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor(value) {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n\n  /**\r\n   * Redo to the previous saved state.\r\n   */\n  redo(editor) {\n    editor.redo();\n  },\n\n  /**\r\n   * Undo to the previous saved state.\r\n   */\n  undo(editor) {\n    editor.undo();\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n\n};\n\n/**\r\n * The `withHistory` plugin keeps track of the operation history of a Slate\r\n * editor as operations are applied to it, using undo and redo stacks.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withHistory = editor => {\n  var e = editor;\n  var {\n    apply\n  } = e;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n\n  e.redo = () => {\n    var {\n      history\n    } = e;\n    var {\n      redos\n    } = history;\n\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (var op of batch) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.pop();\n      history.undos.push(batch);\n    }\n  };\n\n  e.undo = () => {\n    var {\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          var inverseOps = batch.map(Operation.inverse).reverse();\n\n          for (var op of inverseOps) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.push(batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = op => {\n    var {\n      operations,\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch[lastBatch.length - 1];\n    var overwrite = shouldOverwrite(op, lastOp);\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n\n    if (save == null) {\n      save = shouldSave(op);\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp) || overwrite;\n        }\n      }\n\n      if (lastBatch && merge) {\n        if (overwrite) {\n          lastBatch.pop();\n        }\n\n        lastBatch.push(op);\n      } else {\n        var batch = [op];\n        undos.push(batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      if (shouldClear(op)) {\n        history.redos = [];\n      }\n    }\n\n    apply(op);\n  };\n\n  return e;\n};\n/**\r\n * Check whether to merge an operation into the previous operation.\r\n */\n\nvar shouldMerge = (op, prev) => {\n  if (op.type === 'set_selection') {\n    return true;\n  }\n\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation needs to be saved to the history.\r\n */\n\n\nvar shouldSave = (op, prev) => {\n  if (op.type === 'set_selection' && (op.properties == null || op.newProperties == null)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Check whether an operation should overwrite the previous one.\r\n */\n\n\nvar shouldOverwrite = (op, prev) => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation should clear the redos stack.\r\n */\n\n\nvar shouldClear = op => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n\nexport { HISTORY, History, HistoryEditor, MERGING, SAVING, withHistory };\n//# sourceMappingURL=index.es.js.map\n","import classHasFocus from '@utils/classHasFocus';\n\nexport default editor => {\n  const { onChange } = editor;\n\n  let lastSelection = null;\n\n  // enhance onChange method\n  editor.onChange = e => {\n\n    // when focused on the editor, update the selection\n    if (classHasFocus('mms--editor')) {\n      lastSelection = editor.selection;\n    }\n\n    // when focused on an ignore-focus type element\n    // set the selection to its latest value\n    if (classHasFocus('mms--toolbar-ignore-focus')) {\n      if (lastSelection) {\n        editor.selection = lastSelection;\n      }\n    }\n\n    // if onChange provided, call it\n    if (typeof onChange === 'function') {\n      onChange(e);\n    }\n  }\n\n  return editor;\n}\n","import isValidUrl from '@utils/isValidUrl';\nimport insertLink from '@editor/links/insertLink';\nimport { types } from '@config/common';\n\nexport default editor => {\n  const { insertData, insertText, isInline } = editor;\n\n  editor.isInline = element => {\n    return element.type === types.a ? true : isInline(element)\n  }\n\n  editor.insertText = text => {\n    if (text && isValidUrl(text)) insertLink(editor, text);\n    else insertText(text);\n  }\n\n  editor.insertData = data => {\n    const text = data.getData('text/plain');\n\n    if (text && isValidUrl(text)) insertLink(editor, text);\n    else insertData(data);\n  }\n\n  return editor;\n}\n","import { Editor, Transforms } from 'slate';\nimport deserializeHtml from '@editor/deserializer/deserializeHtml/deserializeHtml';\nimport deserializeText from '@editor/deserializer/deserializeText/deserializeText';\n\nexport default (editor, htmlDeserializerOptionsList = []) => {\n  const { insertData } = editor;\n\n  editor.insertData = data => {\n\n    const htmlString = data.getData('text/html');\n    const textString = data.getData('text/plain');\n\n    if (htmlString) {\n      const fragment = deserializeHtml(htmlDeserializerOptionsList)(htmlString);\n      Transforms.insertNodes(editor, fragment);\n      Editor.normalize(editor, { force: true });\n      return;\n    }\n\n    // when pasting plain text, deserialize it\n    // and insert it as fragment\n    if (textString) {\n      const fragment = deserializeText(textString);\n      Transforms.insertNodes(editor, fragment);\n      Editor.normalize(editor, { force: true });\n      return;\n    }\n\n    insertData(data);\n  }\n\n  return editor;\n}\n","import mapReduceFlatten from '@utils/mapReduceFlatten';\n\nexport default (editor, normalizerOptions = []) => {\n  const { normalizeNode } = editor;\n\n  editor.normalizeNode = ([ node, path ]) => {\n\n    const normalizeFns = mapReduceFlatten(normalizerOptions, 'normalize');\n    const changed = normalizeFns.reduce((acc, normalize) => (\n      (typeof normalize === 'function')\n        ? acc || normalize(editor, [ node, path ])\n        : acc\n    ), false);\n\n    // if given normalizers cause a change, we should return\n    // due to the \"multi-pass\" nature of the normalizers\n    // https://docs.slatejs.org/concepts/10-normalizing#multi-pass-normalizing\n    if (changed) return;\n\n    // fall back\n    normalizeNode([ node, path ]);\n  }\n\n  return editor;\n}\n","import { Editor, Transforms } from 'slate';\n\nexport default (editor, execCallback) => {\n  const { insertData } = editor;\n\n  editor.insertData = data => {\n\n    execCallback('onInsertData', data);\n\n    insertData(data);\n  }\n\n  return editor;\n}\n","export default (callbacks = {}, args) => (callbackName, params = {}) => {\n  const functions = callbacks[callbackName];\n  if (!functions || !Array.isArray(functions)) return null;\n  functions\n    .filter(f => typeof f === 'function')\n    .forEach(f => f(args ? { ...args, ...params } : params))\n};\n","import isNil from 'lodash/isNil';\n\n// take a list of objects, reduce into a single object by keys\n// 1. for array values, flatten\n// 2. for non-array values, make them an array\n\nexport default (list = []) => {\n  return list\n    .filter(i => i && typeof i === 'object')\n    .reduce((acc, item) => {\n      const currentAcc = { ...acc };\n\n      // iterate through keys of current object\n      Object.keys(item).forEach(k => {\n        const currentItem = item[k];\n\n        // ignore nil values\n        if (isNil(currentItem)) return;\n\n        // initiate key\n        if (!Array.isArray(currentAcc[k])) {\n          currentAcc[k] = [];\n        }\n\n        // current item: flatten or make array\n        currentAcc[k] = currentAcc[k].concat(currentItem);\n      })\n\n      return currentAcc;\n    }, {})\n};\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nexport default ({ children }) => (\n  ReactDOM.createPortal(children, document.body)\n);\n","import React, { useRef, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Slate, Editable, ReactEditor, withReact, useSlate } from 'slate-react'\nimport { Range, Editor, Transforms, Text, createEditor } from 'slate'\n\nimport Portal from '@components/Portal';\nimport classHasFocus from '@utils/classHasFocus';\n\nconst TooolbarWrapper = props => {\n\n  const inlineTop = useRef(-1000000);\n  const inlineLeft = useRef(-1000000);\n\n  // grab editor instance\n  const editor = useSlate();\n\n  const inlineProps = {\n    position: 'absolute',\n    transform: 'translateX(-50%) translateY(-100%)',\n    marginTop: -12,\n    zIndex: 1,\n  };\n\n  const hasFocus = !!editor.selection && ReactEditor.isFocused(editor);\n  const hasFocusWithin = classHasFocus('mms--toolbar-ignore-focus');\n  const isVisible = (hasFocus || hasFocusWithin) && props.isOpen;\n\n  if (props.inline) {\n\n    // set default values for inline styles\n    inlineProps.opacity = 0;\n    inlineProps.top = -1000000;\n    inlineProps.left = -1000000;\n\n    // calculations are only needed for inline toolbars\n    if (isVisible) {\n\n      // set visible flag\n      inlineProps.opacity = 1;\n\n      // only calculate position if the text editor has focus\n      // use the last known location if focused within\n      if (classHasFocus('mms--editor')) {\n\n        const domSelection = window.getSelection();\n        const domRange = domSelection.getRangeAt(0);\n        const rect = domRange.getBoundingClientRect();\n\n        // calculate top and left location of toolbar\n        const newTop = rect.top + window.pageYOffset;\n        const newLeft = rect.left + window.pageXOffset + rect.width / 2;\n\n        // set styles\n        inlineProps.top = newTop;\n        inlineProps.left = newLeft;\n\n        // update state\n        inlineTop.current = newTop;\n        inlineLeft.current = newLeft;\n\n      } else {\n\n        // update styles with last calculated coordinates\n        inlineProps.top = inlineTop.current;\n        inlineProps.left = inlineLeft.current;\n      }\n    }\n  }\n\n  // construct class name\n  let className = 'mms--toolbar';\n  if (props.inline) className += ' mms--toolbar-inline';\n  if (!props.inline) className += ' mms--toolbar-embedded';\n  if (isVisible) className += ' mms--toolbar-visible';\n  if (!isVisible) className += ' mms--toolbar-hidden';\n\n  const toolbar = (\n    <div\n      inline={props.inline}\n      className={className}\n      style={Object.assign({}, props.style, props.inline ? inlineProps : {})}\n    >\n      {props.children}\n    </div>\n  );\n\n  // wrap in Portal if inline\n  if (props.inline) {\n    return (\n      <Portal>\n        {toolbar}\n      </Portal>\n    );\n  }\n\n  return toolbar;\n};\n\nTooolbarWrapper.propTypes = {\n  style: PropTypes.object,\n  className: PropTypes.string,\n  inline: PropTypes.number,\n  isOpen: PropTypes.bool,\n};\n\nTooolbarWrapper.defaultProps = {\n  inline: 1,\n}\n\nexport default TooolbarWrapper;\n","import React, { useState, useRef } from 'react';\nimport { useSlate } from 'slate-react'\nimport PropTypes from 'prop-types';\nimport get from 'lodash/get';\n\nimport ToolbarWrapper from '@components/toolbar/ToolbarWrapper';\n\nconst ToolbarComponent = ({ functions, formats, ...props }) => {\n\n  // grab editor instance\n  const editor = useSlate();\n\n  // toolbar screen state\n  const [screen, setScreen] = useState(null);\n\n  // props to pass toolbar api children / functions\n  const renderProps = { functions, formats, setScreen, screen, editor };\n\n  // should editor be displayed\n  let isOpen = props.isOpen(renderProps);\n  if (isOpen === null) isOpen = formats.isCollapsed === false;\n\n  // grab the default / current screen from configuration\n  const defaultScreen = get(props, 'defaultScreen', 'default');\n\n  // is user forcing the render of a certain screen\n  const forceScreen = get(props, 'forceScreen');\n  const forcedScreen = typeof forceScreen === 'function'\n    ? forceScreen(renderProps)\n    : null;\n\n  // get current screen, fall back to default screen if\n  // invalid screen is provided, or no screen is forced\n  const screens = get(props, 'screens') || {};\n  const currentScreen = screens[forcedScreen] || screens[screen] || screens[defaultScreen];\n  if (!currentScreen || !Array.isArray(currentScreen)) return null;\n\n  return (\n    <ToolbarWrapper\n      isOpen={isOpen}\n      inline={props.inline ? 1 : 0}\n      style={props.style}\n      className={props.className}\n    >\n      {currentScreen.filter(i => !!i).map((ScreenItem, n) => (\n        <ScreenItem key={`toolbar-item-${n}`} {...renderProps} />\n      ))}\n    </ToolbarWrapper>\n  )\n};\n\nexport const toolbarPropTypes = {\n\n  // inline styles to wrapper\n  style: PropTypes.object,\n\n  // custom class name\n  className: PropTypes.string,\n\n  // make this an inline toolbar\n  inline: PropTypes.bool,\n\n  // function receives the toolbar component props\n  // as argument. return true / false to toggle the\n  // visibility state of the toolbar. this will show\n  // or hide the toolbar on inline mode, and only\n  // toggle the class names for embedded mode.\n  isOpen: PropTypes.func,\n\n  // configuration of screens, their layouts\n  screens: PropTypes.object,\n\n  // default screen id to render\n  defaultScreen: PropTypes.string,\n\n  // function receives the toolbar component props\n  // as argument. return a screen to force render\n  // it despite the active screen state.\n  // return null or omit to not force a screen.\n  forceScreen: PropTypes.func,\n}\n\nToolbarComponent.propTypes = {\n\n  ...toolbarPropTypes,\n\n  // formats object\n  formats: PropTypes.object,\n\n  // functions object\n  functions: PropTypes.object.isRequired,\n};\n\nexport default ToolbarComponent;\n","import React, { useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { Editable } from 'slate-react';\n\nimport Toolbar from '@components/toolbar/Toolbar';\n\nconst MMSEditorConsumer = props => {\n\n  const {\n    toolbar,\n    decorate,\n    children,\n    renderElement,\n    renderLeaf,\n    handleHotkeys,\n    execEvent,\n    apiArgs,\n  } = props;\n\n  /* eslint-disable react/prop-types */\n\n  return (\n    children({\n\n      // functions, formats and other apis\n      ...apiArgs,\n\n      // pass down toolbar component\n      toolbar: (options = {}) => (\n        <Toolbar\n          {...(toolbar || {})}\n          {...options}\n          {...apiArgs}\n        />\n      ),\n\n      // pass down editor component\n      editor: ({\n        id,\n        style,\n        className,\n        placeholder,\n        spellCheck = true,\n        autoCorrect = false,\n        autoCapitalize = false,\n        readOnly = false,\n        autoFocus = false,\n      } = {}) => {\n\n        // construct class name\n        let editorClassName = 'mms--editor';\n        if (className) editorClassName += ` ${className || ''}`;\n        if (readOnly) editorClassName += ' mms--disabled';\n\n        return (\n          <Editable\n            id={id}\n            className={editorClassName}\n            style={style}\n            spellCheck={spellCheck ? 1 : 0}\n            autoFocus={autoFocus ? 1 : 0}\n            autoCorrect={autoCorrect ? 1 : 0}\n            autoCapitalize={autoCapitalize ? 1 : 0}\n            // NOTE: DO NOT pass an anonymous function\n            // ie. decorate={() => /*whatever*/}\n            decorate={decorate}\n            readOnly={readOnly ? 1 : 0}\n            renderElement={renderElement}\n            renderLeaf={renderLeaf}\n            placeholder={placeholder}\n            onCut={event => execEvent('onCut', event)}\n            onCopy={event => execEvent('onCopy', event)}\n            // onPaste event is inconsistent and does not work on some browsers\n            // https://github.com/ianstormtaylor/slate/pull/3670/commits/a04875ce591c5a17f17036f137c9be5ac17c7ec0\n            // onPaste={event => execEvent('onPaste', event)}\n            onBeforeInput={event => execEvent('onBeforeInput', event)}\n            onBlur={event => execEvent('onBlur', event)}\n            onFocus={event => execEvent('onFocus', event)}\n            onClick={event => execEvent('onClick', event)}\n            onCompositionStart={event => execEvent('onCompositionStart', event)}\n            onCompositionEnd={event => execEvent('onCompositionEnd', event)}\n            onDragOver={event => execEvent('onDragOver', event)}\n            onDragStart={event => execEvent('onDragStart', event)}\n            onDrop={event => execEvent('onDrop', event)}\n            onMouseUp={event => execEvent('onMouseUp', event)}\n            onMouseDown={event => execEvent('onMouseDown', event)}\n            onKeyUp={event => execEvent('onKeyUp', event)}\n            onKeyDown={event => {\n              execEvent('onKeyDown', event)\n              handleHotkeys({ event, ...apiArgs })\n            }}\n          />\n        )\n      },\n    })\n  )\n};\n\n/* eslint-enable */\n\nMMSEditorConsumer.propTypes = {\n  toolbar: PropTypes.object,\n  decorate: PropTypes.func,\n  apiArgs: PropTypes.object,\n  children: PropTypes.func,\n  renderElement: PropTypes.func,\n  renderLeaf: PropTypes.func,\n  handleHotkeys: PropTypes.func,\n  execEvent: PropTypes.func,\n};\n\nexport default MMSEditorConsumer;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Bold = React.forwardRef(({ children, style, className, ...rest }, ref) => (\n  <b style={style} className={className}>\n    {children}\n  </b>\n));\n\nBold.propTypes = {\n  children: PropTypes.any,\n  className: PropTypes.string,\n  style: PropTypes.object,\n};\n\nexport default Bold;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Italic = React.forwardRef(({ children, style, className, ...rest }, ref) => (\n  <i style={style} className={className}>\n    {children}\n  </i>\n));\n\nItalic.propTypes = {\n  children: PropTypes.any,\n  className: PropTypes.string,\n  style: PropTypes.object,\n};\n\nexport default Italic;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Underline = React.forwardRef(({ children, style, className, ...rest }, ref) => (\n  <u style={style} className={className}>\n    {children}\n  </u>\n));\n\nUnderline.propTypes = {\n  children: PropTypes.any,\n  className: PropTypes.string,\n  style: PropTypes.object,\n};\n\nexport default Underline;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Strikethrough = React.forwardRef(({ children, style, className, ...rest }, ref) => (\n  <s style={style} className={className}>\n    {children}\n  </s>\n));\n\nStrikethrough.propTypes = {\n  children: PropTypes.any,\n  className: PropTypes.string,\n  style: PropTypes.object,\n};\n\nexport default Strikethrough;\n","import { types } from '@config/common';\n\nimport Bold from '@components/editor/leafs/Bold';\nimport Italic from '@components/editor/leafs/Italic';\nimport Underline from '@components/editor/leafs/Underline';\nimport Strikethrough from '@components/editor/leafs/Strikethrough';\n\nexport default {\n  [types.b]: Bold,\n  [types.i]: Italic,\n  [types.u]: Underline,\n  [types.s]: Strikethrough,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport leafs from '@components/editor/leafs';\n\nconst Leaf = ({ decors = {}, attributes, children, leaf } = {}) => {\n\n  // apply built-ins leafs\n  children = Object.keys(leafs).reduce((acc, leafKey) => {\n\n    // if this leafs key isn't on this node\n    // do not wrap around its component\n    if (!leaf[leafKey]) return acc;\n\n    // wrap the accumulator around this leafs component\n    const Component = leafs[leafKey];\n    return <Component {...attributes}>{acc}</Component>;\n\n  }, children);\n\n  // apply custom decorator leafs\n  Object.keys(decors).forEach(key => {\n\n    // decorator doesn't exist\n    if (!leaf[key]) return;\n\n    // wrap children around component\n    const Component = decors[key];\n    children = <Component dkey={key} {...attributes}>{children}</Component>;\n  })\n\n  return <span {...attributes}>{children}</span>;\n};\n\nLeaf.propTypes = {\n  leaf: PropTypes.object,\n  attributes: PropTypes.object,\n  children: PropTypes.any,\n  decors: PropTypes.object,\n};\n\nexport default Leaf;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Paragraph = ({ children, attributes = {} }) => (\n  <p {...attributes}>\n    {children}\n  </p>\n);\n\nParagraph.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default Paragraph;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Blockquote = ({ children, attributes = {} }) => (\n  <blockquote {...attributes}>\n    {children}\n  </blockquote>\n);\n\nBlockquote.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default Blockquote;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst HeadingOne = ({ children, attributes = {} }) => (\n  <h1 {...attributes}>\n    {children}\n  </h1>\n);\n\nHeadingOne.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default HeadingOne;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst HeadingTwo = ({ children, attributes = {} }) => (\n  <h2 {...attributes}>\n    {children}\n  </h2>\n);\n\nHeadingTwo.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default HeadingTwo;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst HeadingThree = ({ children, attributes = {} }) => (\n  <h3 {...attributes}>\n    {children}\n  </h3>\n);\n\nHeadingThree.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default HeadingThree;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst Link = ({ children, attributes = {}, element = {} }) => (\n  <a href={element.href} target='_new' {...attributes}>\n    {children}\n  </a>\n);\n\nLink.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n  element: PropTypes.object,\n};\n\nexport default Link;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ListBulleted = ({ children, attributes = {} }) => (\n  <ul {...attributes}>\n    {children}\n  </ul>\n);\n\nListBulleted.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default ListBulleted;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ListNumbered = ({ children, attributes = {} }) => (\n  <ol {...attributes}>\n    {children}\n  </ol>\n);\n\nListNumbered.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default ListNumbered;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ListItem = ({ children, attributes = {} }) => (\n  <li {...attributes}>\n    {children}\n  </li>\n);\n\nListItem.propTypes = {\n  children: PropTypes.any,\n  attributes: PropTypes.object,\n};\n\nexport default ListItem;\n","import { types } from '@config/common';\n\nimport Paragraph from '@components/editor/elements/Paragraph';\nimport Blockquote from '@components/editor/elements/Blockquote';\nimport HeadingOne from '@components/editor/elements/HeadingOne';\nimport HeadingTwo from '@components/editor/elements/HeadingTwo';\nimport HeadingThree from '@components/editor/elements/HeadingThree';\nimport Link from '@components/editor/elements/Link';\nimport ListBulleted from '@components/editor/elements/ListBulleted';\nimport ListNumbered from '@components/editor/elements/ListNumbered';\nimport ListItem from '@components/editor/elements/ListItem';\n\nexport default {\n  [types.p]: Paragraph,\n  [types.q]: Blockquote,\n  [types.h1]: HeadingOne,\n  [types.h2]: HeadingTwo,\n  [types.h3]: HeadingThree,\n  [types.a]: Link,\n  [types.ul]: ListBulleted,\n  [types.ol]: ListNumbered,\n  [types.li]: ListItem,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { types } from '@config/common';\nimport elements from '@components/editor/elements';\n\nconst Element = ({ attributes, children, element = {} }) => {\n  const Component = elements[element.type] || elements[types.p];\n  return (\n    <Component\n      attributes={attributes}\n      element={element}\n    >\n      {children}\n    </Component>\n  );\n};\n\nElement.propTypes = {\n  attributes: PropTypes.object,\n  element: PropTypes.object,\n  children: PropTypes.any,\n};\n\nexport default Element;\n","import React, { useCallback } from 'react';\nimport Leaf from '@components/editor/Leaf';\nimport Element from '@components/editor/Element';\n\nexport default ({\n  leafUpdater,\n  decorComponents,\n  decorTriggers\n}) => {\n\n  const renderElement = useCallback(props => {\n    return <Element {...props} />\n  }, []);\n\n  const renderLeaf = useCallback(props => {\n    return <Leaf decors={decorComponents} {...props} />;\n  }, [decorTriggers, leafUpdater]);\n\n  return {\n    renderLeaf,\n    renderElement,\n  }\n};\n","// Will be invoked in `onKeyDown`\n// e.preventDefault() to stop keystroke from registering\nimport isHotkey from 'is-hotkey';\nimport prepareHotkeys from '@editor/hotkeys/prepareHotkeys';\n\nexport default hotkeys => {\n  const dict = prepareHotkeys(hotkeys);\n\n  // curry hotkey validators\n  const validators = Object.keys(dict).reduce((acc, key) => (\n    { ...acc, [key]: isHotkey(key) }\n  ), {});\n\n  return ({ event, ...rest }) => {\n    Object.keys(dict).forEach(key => {\n\n      // grab curried validator functions\n      const validate = validators[key];\n      if (typeof validate !== 'function') return;\n\n      // execute wrapped logic if hotkey detected\n      if (validate(event)) {\n\n        // execute the array of wrapped logic arr\n        (dict[key] || [])\n          .filter(f => typeof f === 'function')\n          .forEach(f => f({ event, ...rest }))\n      }\n    })\n  }\n};\n","// convert the keybinding array into a dictionary grouped by hotkey,\n// with values being an array of logic for given binding\nimport isNil from 'lodash/isNil';\n\nexport default (hotkeys = []) => {\n  return hotkeys.reduce((acc, k = {}) => {\n    const key = (k.key || '').toLowerCase();\n    if (!key) return acc;\n\n    // combine `when` claus with `command` into one function\n    const logic = ({ event, formats, functions } = {}) => {\n      // ignore if command not a function\n      if (typeof k.command !== 'function') return;\n      // should run if when clause is truthy, or a function that returns truthy\n      const when = isNil(k.when) ? true : k.when;\n      const shouldRun = (typeof when === 'function') ? !!when({ event, formats }) : !!when;\n      // execute command, pass functions api\n      if (shouldRun) k.command({ event, functions });\n    }\n\n    return Object.assign({}, acc, {\n      [key]: (acc[key] || []).concat(logic)\n    })\n  }, {})\n};\n","import { useCallback } from 'react';\nimport getExecuteEvent from '@editor/events/getExecuteEvent';\nimport getExecuteCallback from '@editor/events/getExecuteCallback';\n\nexport default (events, callbacks, args) => {\n  const execEvent = useCallback(getExecuteEvent(events, args), [events, args]);\n  const execCallback = useCallback(getExecuteCallback(callbacks, args), [callbacks, args]);\n\n  return {\n    execEvent,\n    execCallback,\n  }\n};\n","export default (events = {}, args) => (eventName, event) => {\n  const functions = events[eventName];\n  if (!functions || !Array.isArray(functions)) return null;\n  functions\n    .filter(f => typeof f === 'function')\n    .forEach(f => f(event, args))\n};\n","var TARGET = typeof Symbol === 'undefined' ? '__target' : Symbol(),\n    SCRIPT_TYPE = 'application/javascript',\n    BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,\n    URL = window.URL || window.webkitURL,\n    Worker = window.Worker;\n\n/**\n * Returns a wrapper around Web Worker code that is constructible.\n *\n * @function shimWorker\n *\n * @param { String }    filename    The name of the file\n * @param { Function }  fn          Function wrapping the code of the worker\n */\nexport default function shimWorker (filename, fn) {\n    return function ShimWorker (forceFallback) {\n        var o = this;\n\n        if (!fn) {\n            return new Worker(filename);\n        }\n        else if (Worker && !forceFallback) {\n            // Convert the function's inner code to a string to construct the worker\n            var source = `${ fn }`.replace(/^function.+?{/, '').slice(0, -1),\n                objURL = createSourceObject(source);\n\n            this[TARGET] = new Worker(objURL);\n            URL.revokeObjectURL(objURL);\n            return this[TARGET];\n        }\n        else {\n            var selfShim = {\n                    postMessage: m => {\n                        if (o.onmessage) {\n                            setTimeout(() => o.onmessage({ data: m, target: selfShim }));\n                        }\n                    }\n                };\n\n            fn.call(selfShim);\n            this.postMessage = m => {\n                setTimeout(() => selfShim.onmessage({ data: m, target: o }));\n            };\n            this.isThisThread = true;\n        }\n    };\n};\n\n// Test Worker capabilities\nif (Worker) {\n    var testWorker,\n        objURL = createSourceObject('self.onmessage = function () {}'),\n        testArray = new Uint8Array(1);\n\n    try {\n        // No workers via blobs in Edge 12 and IE 11 and lower :(\n        if (/(?:Trident|Edge)\\/(?:[567]|12)/i.test(navigator.userAgent)) {\n            throw new Error('Not available');\n        }\n        testWorker = new Worker(objURL);\n\n        // Native browser on some Samsung devices throws for transferables, let's detect it\n        testWorker.postMessage(testArray, [testArray.buffer]);\n    }\n    catch (e) {\n        Worker = null;\n    }\n    finally {\n        URL.revokeObjectURL(objURL);\n        if (testWorker) {\n            testWorker.terminate();\n        }\n    }\n}\n\nfunction createSourceObject(str) {\n    try {\n        return URL.createObjectURL(new Blob([str], { type: SCRIPT_TYPE }));\n    }\n    catch (e) {\n        var blob = new BlobBuilder();\n        blob.append(str);\n        return URL.createObjectURL(blob.getBlob(type));\n    }\n}\n","import shimWorker from 'rollup-plugin-bundle-worker';\nexport default new shimWorker(\"./decorateWorker.js\", function (window, document) {\nvar self = this;\n// mock self for tests\nconst _self = (this && this.self) ? this.self : {};\n\nconst GENERATE_DEBOUNCE = 200;\n\nconst walkAcc = (node, path, fn) => {\n  fn(node, path);\n  (node.children || []).map((child, i) => {\n    walkAcc(child, path.concat(i), fn)\n  })\n}\n\nconst walk = (children, fn) => {\n  children.map((child, i) => {\n    walkAcc(child, [i], fn);\n  })\n}\n\n// ridiculous workaround for web worker\n// \"_defineProperty$1 not defined\" issue\nconst defineProp = (object, key, value) => {\n  Object.defineProperty(object, key, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true,\n  });\n}\n\n// generate ranges from editor children\nconst generateRanges = ({ children, decorators = [] }) => {\n  let total = 0;\n  const matches = {};\n  const aggregates = {};\n  const ranges = [];\n\n  // process regular expression against node text\n  const processRegex = (node, path, d, rgx) => {\n    let terms = [];\n    while ((terms = rgx.exec(node.text)) !== null) {\n\n      // matched term\n      const term = (terms[0] || '');\n      const termSafe = term.toLowerCase();\n\n      // keep stats of matches\n      if (!matches[d.id][termSafe]) defineProp(matches[d.id], termSafe, 0);\n      defineProp(matches[d.id], termSafe, (matches[d.id][termSafe] || 0) + 1);\n      defineProp(aggregates, d.id, aggregates[d.id] + 1);\n      total += 1;\n\n      // create range object\n      const range = {\n        anchor: { path, offset: terms.index },\n        focus: { path, offset: terms.index + term.length },\n      };\n\n      // insert decorator key\n      defineProp(range, d.key, true);\n      ranges.push(range);\n    }\n  }\n\n  walk(children, (node, path) => {\n\n    // only run for text nodes\n    if (!node.text) return;\n\n    // loop through decorators\n    decorators.filter(d => d.regex).forEach(d => {\n\n      // initiate matches and aggregates\n      if (!matches[d.id]) defineProp(matches, d.id, {});\n      if (!aggregates[d.id]) defineProp(aggregates, d.id, 0);\n\n      // match here\n      if (Array.isArray(d.regex)) {\n        d.regex.forEach(rg => {\n          processRegex(node, path, d, rg);\n        })\n      } else {\n        processRegex(node, path, d, d.regex);\n      }\n    })\n  })\n\n  // sort ranges by area they're covering, so longer\n  // decorations are printed at the bottom and shorter\n  // ones are printed on top of them\n  ranges.sort((r1, r2) => {\n    const d1 = Math.abs(r1.anchor.offset - r1.focus.offset);\n    const d2 = Math.abs(r2.anchor.offset - r2.focus.offset);\n    return d2 - d1;\n  })\n\n  // organize ranges in a dictionary for\n  // better performance in decorate function\n  const rangesDict = ranges.reduce((acc, r) => {\n    // anchor and focus paths are the same for decorators\n    // so we can pick up path from either of them\n    const path = r.anchor.path.join('-');\n    defineProp(acc, path, (acc[path] || []).concat(r));\n    return acc;\n  }, {});\n\n  return {\n    ranges,\n    rangesDict,\n    matches,\n    aggregates,\n    total,\n  };\n}\n\n// worker is invoked\n_self.onmessage = function(e) {\n  const data = e.data || {};\n  const commands = data.commands || {};\n  const command = data.command;\n  const echo = data.echo;\n\n  // base response to all messaging\n  const base = { command, echo };\n\n  // generate ranges command\n  if (command === commands.generate) {\n    const children = data.children;\n    const decorators = data.decorators || [];\n\n    // wait for some time for debounce effect\n    setTimeout(() => {\n      const res = generateRanges({ children, decorators });\n      _self.postMessage(Object.assign({}, base, res));\n    }, GENERATE_DEBOUNCE)\n  }\n};\n\n\n});","const PREFIX = 'mms-custom-decorator-';\nexport default id => `${PREFIX}${id}`;\n","// takes decorators and return a dictionary with keys being\n// decorator keys, and values being components to wrap the\n// leafs around\n\nimport React from 'react';\nimport getDecoratorKey from '@editor/decorators/utils/getDecoratorKey';\n\n/* eslint-disable react/prop-types */\n\nexport default (decorators = []) => {\n  return decorators.reduce((acc, decorator) => {\n\n    let Component = null;\n\n    // if a component is provided, use it\n    if (decorator.component) {\n      Component = decorator.component\n    }\n\n    // component styles are provided\n    if (decorator.style) {\n      Component = props => (\n        <span data-decorator={decorator.id} style={decorator.style}>\n          {props.children}\n        </span>\n      );\n    }\n\n    // a render function is provided\n    if (decorator.render) {\n      Component = props => (\n        <span data-decorator={decorator.id}>\n          {decorator.render(props)}\n        </span>\n      )\n    }\n\n    return Object.assign({}, acc, {\n      [getDecoratorKey(decorator.id)]: Component\n    })\n  }, {})\n};\n","export default (decorators = []) =>\n  decorators.reduce((acc, d) => acc.concat(d.triggers), []);\n","// regular expressions needs to be executed globally\n// make sure regular expressions has that flag\nexport default regex => {\n  let flags = regex.flags;\n  if (flags.indexOf('g') === -1) flags = `g${flags}`;\n  return new RegExp(regex, flags);\n}\n","// default transformation for the terms\n// to be matched against\nexport default (str = '') => str.trim();\n","// is string a valid value for being\n// considered as a decorator\nexport default str => {\n  if (!str) return false;\n  if (str.length < 2) return false;\n  return true;\n};\n","import normalizeString from '@editor/decorators/utils/normalizeString';\nimport isStringValid from '@editor/decorators/utils/isStringValid';\n\nexport default (str = '', { wholeWord = false } = {}) => {\n  let useString = normalizeString(String(str));\n  if (!isStringValid(useString)) return null;\n  if (wholeWord) useString = `\\\\b${useString}\\\\b`;\n  return new RegExp(useString, 'gi');\n};\n","import { useState } from 'react';\nimport { Text } from 'slate';\n/* eslint-disable import/no-webpack-loader-syntax */\nimport DecorateWorker from 'worker!./decorateWorker.js';\nimport getDecorComponents from '@editor/decorators/getDecorComponents';\nimport getDecorTriggers from '@editor/decorators/getDecorTriggers';\nimport getDecoratorKey from '@editor/decorators/utils/getDecoratorKey';\nimport regexFromRegex from '@editor/decorators/utils/regexFromRegex';\nimport regexFromString from '@editor/decorators/utils/regexFromString';\nimport isTest from '@utils/test/isTest';\n\n// commands dict\nconst commands = {\n  generate: 'generage-ranges',\n}\n\n// decorator class\nclass Decorator {\n\n  // instantiate worker\n  constructor() {\n    this.initiate();\n    this.editor = null;\n    this.triggers = [];\n    this.components = {};\n    this.ranges = [];\n    this.rangesDict = {};\n    this.total = 0;\n    this.matches = {};\n    this.aggregates = {};\n  }\n\n  useLeafUpdater() {\n    const [ leafUpdater, setLeafUpdater ] = useState(0);\n    this.leafUpdater = leafUpdater;\n    this.setLeafUpdater = setLeafUpdater;\n    return leafUpdater;\n  }\n\n  forceRenderLeafs() {\n    this.setLeafUpdater(this.leafUpdater + 1)\n    this.leafUpdater += 1;\n  }\n\n  // set a ref to the editor object\n  setEditor(editor) {\n    this.editor = editor;\n  }\n\n  // return object to be passed as decors\n  getDecors() {\n    return {\n      matches: this.matches,\n      aggregates: this.aggregates,\n      total: this.total,\n    }\n  }\n\n  // extract values from decorator list\n  applyPlugins(decorators = []) {\n\n    // pre-calculate decorator values\n    this.decoratorsSerializable = decorators.map(d => {\n\n      // create regex\n      let regex = d.match;\n      if (regex instanceof RegExp) regex = regexFromRegex(regex);\n      if (typeof regex === 'string') regex = regexFromString(regex);\n      if (Array.isArray(regex)) {\n        regex = d.match\n          .map(s => regexFromString(s, { wholeWord: true }))\n          .filter(Boolean)\n          .map(regexFromRegex);\n      }\n      if (!Array.isArray(regex) && regex instanceof RegExp !== true) {\n        regex = null;\n      }\n\n      const id = d.id;\n      const key = getDecoratorKey(id);\n\n      // return a serializable object\n      // to pass on to the worker\n      return { regex, id, key };\n    });\n\n    // extract components\n    this.triggers = getDecorTriggers(decorators);\n    this.components = getDecorComponents(decorators);\n\n    // trigger generate ranges cycle with timeout\n    this.generateRanges();\n  }\n\n  // start web worker\n  initiate() {\n    // bail if test\n    if (isTest()) return;\n    // instantiate web worker\n    this.worker = new DecorateWorker();\n    this.worker.onmessage = e => {\n      this.onResponse(e.data);\n    }\n  }\n\n  // terminate worker\n  terminate() {\n    this.worker.terminate();\n  }\n\n  // when worker gets invoked rapidly, it will unlikely\n  // have enough time to finish the last process, and\n  // eventually stack up and crash. to avoid this,\n  // terminate the current running process and start a new\n  // one, so only the last invocation will take effect\n  restart() {\n    this.terminate();\n    this.initiate();\n  }\n\n  // start the worker\n  generateRanges() {\n    if (!this.worker) return;\n    if (!this.editor) return;\n\n    // kill old process and start a new one\n    this.restart();\n\n    // send signal to worker\n    this.worker.postMessage({\n      command: commands.generate,\n      children: this.editor.children,\n      decorators: this.decoratorsSerializable,\n      commands,\n    });\n  }\n\n  // response received from webworker\n  onResponse(res = {}) {\n\n    // generate callback\n    if (res.command === commands.generate) {\n      this.ranges = res.ranges;\n      this.rangesDict = res.rangesDict;\n      this.matches = res.matches;\n      this.aggregates = res.aggregates;\n      this.total = res.total;\n      // call onChange to trigger decoration cycle\n      this.editor.onChange();\n      // force rerender leafs to register decorations\n      this.forceRenderLeafs();\n    }\n  }\n\n  decorate = ([ node, path ]) => {\n    if (!Text.isText(node)) return [];\n    const pathJoined = path.join('-');\n    return this.rangesDict[pathJoined] || [];\n  }\n}\n\n// export singleton since we only need one worker\nexport default new Decorator();\n","export default () => typeof jest === 'object';\n","import React, { useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { useSlate } from 'slate-react';\nimport { FormatsApiContext } from '@editor/hooks/useFormats';\nimport { FunctionsApiContext } from '@editor/hooks/useFunctions';\nimport { DecoratorContext } from '@editor/hooks/useDecors';\nimport MMSEditorConsumer from '@/MMSEditorConsumer';\nimport useRenderers from '@components/editor/useRenderers';\nimport useHotkeys from '@editor/hotkeys/useHotkeys';\nimport useEvents from '@editor/events/useEvents';\nimport decorator from '@editor/decorators/decorator';\nimport getFormats from '@editor/formats';\nimport getFunctions from '@editor/functions';\n\nconst MMSEditorProvider = props => {\n  const editor = useSlate();\n\n  const {\n    children,\n    value,\n    state,\n    setValue,\n    setState,\n    pluginsDict,\n  } = props;\n\n  const {\n    events,\n    callbacks,\n    toolbar,\n    hotkeys,\n    decorators,\n    extendCore,\n    htmlDeserializerOptionsList,\n  } = pluginsDict;\n\n  // extend functions and formats\n  const formatsRaw = getFormats(editor, { state });\n  const functionsRaw = getFunctions(editor, { setState, setValue, htmlDeserializerOptionsList });\n  const { formats, functions } = extendCore({ formatsRaw, functionsRaw });\n\n  // initiate decorator\n  useEffect(() => { decorator.setEditor(editor); }, []);\n  useEffect(() => { decorator.applyPlugins(decorators); }, [decorators])\n\n  // value to watch for forcing memoised\n  // renderLeaf function to get executed\n  const leafUpdater = decorator.useLeafUpdater();\n\n  // api's packed together in a single object.\n  // destructure before passing on\n  const apiArgs = {\n    formats,\n    functions,\n    decors: decorator.getDecors(),\n  };\n\n  // element / leaf renderers\n  const {\n    renderLeaf,\n    renderElement\n  } = useRenderers({\n    leafUpdater,\n    decorComponents: decorator.components,\n    decorTriggers: decorator.triggers,\n  });\n\n  // hotkeys\n  const handleHotkeys = useHotkeys(hotkeys);\n\n  // events\n  const {\n    execEvent,\n    execCallback\n  } = useEvents(events, callbacks, apiArgs);\n\n  // on change\n  useEffect(() => {\n    execCallback('onValueChange');\n    decorator.generateRanges();\n  }, [value]);\n\n  return (\n    <FormatsApiContext.Provider value={formats}>\n      <FunctionsApiContext.Provider value={functions}>\n        <DecoratorContext.Provider value={{}}>\n          <MMSEditorConsumer\n            toolbar={toolbar}\n            decorate={decorator.decorate}\n            renderElement={renderElement}\n            renderLeaf={renderLeaf}\n            handleHotkeys={handleHotkeys}\n            execEvent={execEvent}\n            execCallback={execCallback}\n            apiArgs={apiArgs}\n          >\n            {children}\n          </MMSEditorConsumer>\n        </DecoratorContext.Provider>\n      </FunctionsApiContext.Provider>\n    </FormatsApiContext.Provider>\n  )\n};\n\nMMSEditorProvider.propTypes = {\n  pluginsDict: PropTypes.object,\n  children: PropTypes.func,\n  value: PropTypes.array,\n  state: PropTypes.object,\n  setValue: PropTypes.func,\n  setState: PropTypes.func,\n};\n\nexport default MMSEditorProvider;\n","import { types } from '@config/common';\nimport isFormatActive from '@editor/formatters/isFormatActive';\nimport isCollapsed from '@editor/cursor/isCollapsed';\nimport isFocused from '@editor/focus/hasFocus';\n\nexport default (editor, { state }) => {\n\n  const isH1 = isFormatActive(editor, 'block', types.h1);\n  const isH2 = isFormatActive(editor, 'block', types.h2);\n  const isH3 = isFormatActive(editor, 'block', types.h3);\n  const isHeading = isH1 || isH2 || isH3;\n\n  return {\n\n    // marks\n    isBold: isFormatActive(editor, 'mark', types.b),\n    isItalic: isFormatActive(editor, 'mark', types.i),\n    isUnderline: isFormatActive(editor, 'mark', types.u),\n    isStrikethrough: isFormatActive(editor, 'mark', types.s),\n\n    // blocks\n    isH1,\n    isH2,\n    isH3,\n    isHeading,\n    isLink: isFormatActive(editor, 'block', types.a),\n    isParagraph: isFormatActive(editor, 'block', types.p),\n    isBlockquote: isFormatActive(editor, 'block', types.q),\n    isListNumbered: isFormatActive(editor, 'block', types.ol),\n    isListBulleted: isFormatActive(editor, 'block', types.ul),\n\n    // misc\n    isCollapsed: isCollapsed(editor),\n    isFocused: isFocused(editor),\n\n    // state\n    state,\n\n    // TODO: Editor.marks won't return custom formats\n    // isDecor: id => isFormatActive(editor, 'mark', getDecoratorKey(id)),\n  }\n};\n","import { types } from '@config/common';\nimport focus from '@editor/focus/focus';\nimport hasFocus from '@editor/focus/hasFocus';\nimport moveCursorToStart from '@editor/cursor/moveCursorToStart';\nimport moveCursorToEnd from '@editor/cursor/moveCursorToEnd';\nimport getLink from '@editor/links/getLink';\nimport replaceLink from '@editor/links/replaceLink';\nimport insertLink from '@editor/links/insertLink';\nimport removeLink from '@editor/links/removeLink';\nimport selectAll from '@editor/contents/selectAll';\nimport clear from '@editor/contents/clear';\nimport isEmpty from '@editor/contents/isEmpty';\nimport getPlainText from '@editor/contents/getPlainText';\nimport toggleFormat from '@editor/formatters/toggleFormat';\nimport exportFn from '@editor/data/export';\nimport exportHtml from '@editor/data/exportHtml';\nimport importFn from '@editor/data/import';\nimport insertHtml from '@editor/data/insertHtml';\nimport insertText from '@editor/data/insertText';\nimport toggleHeading from '@editor/formatters/toggleHeading';\nimport populateWindow from '@utils/test/populateWindow';\n\nexport default (editor, {\n  setValue,\n  setState,\n  htmlDeserializerOptionsList } = {}\n) => ({\n\n  // focus\n  focus: () => focus(editor),\n  hasFocus: () => hasFocus(editor),\n\n  // cursor\n  moveCursorToStart: () => moveCursorToStart(editor),\n  moveCursorToEnd: () => moveCursorToEnd(editor),\n\n  // content\n  selectAll: () => selectAll(editor),\n  isEmpty: () => isEmpty(editor),\n  clear: () => clear(editor, setValue),\n  getPlainText: () => getPlainText(editor),\n\n  // links\n  getLink: () => getLink(editor),\n  replaceLink: url => replaceLink(editor, url),\n  insertLink: url => insertLink(editor, url),\n  removeLink: () => removeLink(editor),\n\n  // formatters\n  toggleBold: status => toggleFormat(editor, 'mark', types.b, { status }),\n  toggleItalic: status => toggleFormat(editor, 'mark', types.i, { status }),\n  toggleUnderline: status => toggleFormat(editor, 'mark', types.u, { status }),\n  toggleStrikethrough: status => toggleFormat(editor, 'mark', types.s, { status }),\n  toggleBlockquote: status => toggleFormat(editor, 'block', types.q, { status }),\n  toggleListBulleted: status => toggleFormat(editor, 'block', types.ul, { status }),\n  toggleListNumbered: status => toggleFormat(editor, 'block', types.ol, { status }),\n  toggleHeading: (level, status) => toggleHeading(editor, level, status),\n\n  // data\n  import: raw => importFn(editor, setValue, raw),\n  export: options => exportFn(editor, options),\n  exportHtml: () => exportHtml(editor),\n  insertHtml: (html, options) => insertHtml(editor, html, options || htmlDeserializerOptionsList),\n  insertText: text => insertText(editor, text),\n\n  // state\n  setState,\n\n  // internals\n  _setValue: setValue,\n  _getEditor: () => editor,\n  _populateWindow: () => populateWindow(editor),\n});\n","import { useCallback } from 'react';\nimport getHandleHotkeys from '@editor/hotkeys/getHandleHotkeys';\n\nexport default hotkeys => {\n  return useCallback(getHandleHotkeys(hotkeys), [hotkeys]);\n};\n","import React, { useMemo, useRef, useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { createEditor } from 'slate';\nimport { Slate } from 'slate-react';\n\n// bundler will pick up the style import below and\n// turn it into an autoprefixed standalone css file\nimport '@config/defaultStyles';\n\nimport initialValue from '@config/initialValue';\nimport withMarketmuse from '@editor/enhancer/withMarketmuse';\nimport applyPlugins from '@editor/plugins/applyPlugins';\nimport MMSEditorProvider from '@/MMSEditorProvider';\n\nconst MMSEditor = props => {\n\n  const { children, plugins, useDefaultPlugins } = props;\n\n  // merge plugins\n  const mergePlugins = () => applyPlugins(plugins, { useDefaultPlugins });\n  const pluginsDict = useMemo(mergePlugins, [plugins]);\n\n  // create editor\n  const editor = useMemo(() => withMarketmuse(createEditor(), pluginsDict), [])\n\n  // Having the editor be uncontrolled seems to make more sense given that the\n  // value will be slate-specific JSON syntax and won't mean much without further\n  // processing / parsing. Editor component should take that responsibility, so\n  // the data should be exposed through an api in a meaningful way, and it should\n  // keep its own internal state.\n  const [value, setValue] = useState(initialValue);\n  const [state, setState] = useState({});\n\n  return (\n    <Slate\n      editor={editor}\n      value={value}\n      onChange={setValue}\n    >\n      <MMSEditorProvider\n        value={value}\n        state={state}\n        setValue={setValue}\n        setState={setState}\n        pluginsDict={pluginsDict}\n      >\n        {children}\n      </MMSEditorProvider>\n    </Slate>\n  );\n};\n\nMMSEditor.propTypes = {\n\n  // to use editor instead of creating one\n  children: PropTypes.any,\n\n  // use default options\n  useDefaultPlugins: PropTypes.bool,\n\n  // an object containing extension functions\n  plugins: PropTypes.arrayOf(\n    PropTypes.shape({\n      formats: PropTypes.function,\n      functions: PropTypes.function,\n      hotkeys: PropTypes.array,\n      decorators: PropTypes.array,\n      htmlDeserializerOptions: PropTypes.object,\n    })\n  )\n};\n\nMMSEditor.defaultProps = {\n  useDefaultPlugins: true,\n}\n\nexport default MMSEditor;\n","import * as defaultPlugins from '@plugins';\nimport mapReduceFlattenDict from '@utils/mapReduceFlattenDict';\n\nexport default (plugins = [], { useDefaultPlugins } = {}) => {\n\n  // apply plugins\n  const useDefaults = useDefaultPlugins ? Object.values(defaultPlugins) : [];\n  const usePlugins = useDefaults.concat(plugins || []);\n\n  const {\n    toolbar,\n    hotkeys,\n    decorators,\n    normalizerOptions: normalizerOptionsList,\n    htmlDeserializerOptions: htmlDeserializerOptionsList,\n    onValueChange,\n    onInsertData,\n    onKeyUp,\n    onKeyDown,\n    onCut,\n    onCopy,\n    onPaste,\n    onBeforeInput,\n    onBlur,\n    onFocus,\n    onClick,\n    onMouseUp,\n    onMouseDown,\n    onCompositionStart,\n    onCompositionEnd,\n    onDragOver,\n    onDragStart,\n    onDrop,\n  } = mapReduceFlattenDict(usePlugins);\n\n  // generate function to extend core api's\n  const extendCore = ({ functionsRaw, formatsRaw }) => (\n    usePlugins.reduce((acc, plugin = {}) => {\n      if (typeof plugin !== 'object') return acc;\n\n      // extend formats\n      const newFormats = typeof plugin.formats === 'function'\n        ? plugin.formats(acc.formats, { functions: acc.functions })\n        : acc.formats;\n\n      // extend functions\n      const newFunctions = typeof plugin.functions === 'function'\n        ? plugin.functions(acc.functions, { formats: acc.formats })\n        : acc.functions\n\n      // return formats and functions\n      return {\n        formats: newFormats,\n        functions: newFunctions\n      }\n    }, {\n      formats: formatsRaw,\n      functions: functionsRaw,\n    })\n  )\n\n  return {\n    toolbar: toolbar.length > 0 ? toolbar[0] : null,\n    hotkeys,\n    decorators,\n    extendCore,\n    normalizerOptionsList,\n    htmlDeserializerOptionsList,\n    callbacks: {\n      onValueChange,\n      onInsertData,\n    },\n    events: {\n      onKeyUp,\n      onKeyDown,\n      onCut,\n      onCopy,\n      onPaste,\n      onBeforeInput,\n      onBlur,\n      onFocus,\n      onClick,\n      onMouseUp,\n      onMouseDown,\n      onCompositionStart,\n      onCompositionEnd,\n      onDragOver,\n      onDragStart,\n      onDrop,\n    }\n  }\n}\n","import { withReact } from 'slate-react';\nimport { withHistory } from 'slate-history';\nimport withPersistedSelection from '@editor/enhancer/withPersistedSelection';\nimport withLinks from '@editor/enhancer/withLinks';\nimport withDeserializer from '@editor/enhancer/withDeserializer';\nimport withNormalizer from '@editor/enhancer/withNormalizer';\nimport withOnInsertData from '@editor/enhancer/withOnInsertData';\nimport getExecuteCallback from '@editor/events/getExecuteCallback';\n\nexport default (editor, {\n  test,\n  htmlDeserializerOptionsList = [],\n  normalizerOptionsList = [],\n  callbacks,\n} = {}) => {\n\n  // this is a function which will run callbacks before editor initialization\n  // and act as an enhancer, so it will not have access to typical arguments\n  const execCallback = getExecuteCallback(callbacks, null);\n\n  let useEditor = editor;\n\n  if (!test) useEditor = withReact(useEditor);\n  useEditor = withPersistedSelection(useEditor);\n  useEditor = withHistory(useEditor);\n  useEditor = withLinks(useEditor);\n  useEditor = withNormalizer(useEditor, normalizerOptionsList);\n  useEditor = withDeserializer(useEditor, htmlDeserializerOptionsList);\n  useEditor = withOnInsertData(useEditor, execCallback);\n\n  return useEditor;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}